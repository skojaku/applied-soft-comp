{
  "hash": "813266a504b215bc602c5c241c532283",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"The Tidy Data Philosophy\"\njupyter: python3\nexecute:\n    enabled: true\n---\n\n::: {.callout-note title=\"What you'll learn in this module\"}\nThis module introduces the tidy data philosophy. You'll learn what makes data \"tidy\" and what pitfalls to avoid, explore practical tools like melt and pivot to reshape your data, and understand why standardizing data structure makes analysis faster and more reliable.\n:::\n\n## The 80% Problem\n\nIt is often said that 80% of data analysis is spent cleaning and preparing data. This isn't an exaggeration. Getting your data into the right shape makes everything else easier. The good news is that once you understand the tidy data philosophy, you can apply it consistently across projects.\n\nIf you want to dive deeper, read [Tidy Data by Hadley Wickham](https://vita.had.co.nz/papers/tidy-data.pdf).\n\n\n## What is Tidy Data?\n\nAt its core, tidy data is a standard way of mapping the meaning of a dataset to its structure. Whether your data is messy or tidy depends entirely on how rows, columns, and tables match up with observations, variables, and types.\n\nLet's talk about the three core principles. First, each variable forms its own column. A variable measures the same underlying attribute (like height, temperature, or duration) across different units. Second, each observation forms a row. An observation captures all measurements on the same unit (like a person, a day, or a race) across different attributes. Third, each type of observational unit gets its own table. In a study of allergy medication, you'd have separate tables for demographic data, daily medical data, and meteorological data, not one giant table mixing everything together.\n\nWhy does this matter? Tidy datasets are dramatically easier to manipulate, model, and visualize. They make exploration faster and analysis clearer. Most importantly, they standardize data organization, making your code reusable and reliable.\n\n### Common Pitfalls\n\nNow let's flip the perspective and look at the most common mistakes. When you first encounter messy data, it usually falls into one of five patterns.\n\nThe first problem is that column headers often contain values instead of variable names. Imagine a table where months (\"Jan\", \"Feb\", \"Mar\") are the column headers, rather than having a single \"Month\" column with those values. This makes it hard to analyze across months.\n\nThe second problem is multiple variables stored in one column. You might find a column like \"height_weight\" containing values like \"5.5_130\" instead of splitting those into separate \"height\" and \"weight\" columns. This breaks apart information that belongs together.\n\nThe third problem is variables scattered across both rows and columns. A piece of information like gender might be encoded in a specific column and also hidden within the values of another column, creating redundancy and confusion during analysis.\n\nThe fourth problem is mixing different types of observational units in one table. For example, a single table containing both patient demographic information and medical test results mashes two fundamentally different kinds of data together.\n\nThe fifth and final problem is splitting a single observational unit across multiple tables. Patient information scattered across one table for addresses, another for test results, and another for appointments, with no clean way to link them together, makes every analysis painful.\n\n## Tidy Tools\n\nNow let's learn practical tools to reshape your messy data into tidy form. The examples here are adapted from [Python for Data Science](https://aeturrell.github.io/python4DS/data-tidy.html).\n\n### Melt: From Wide to Long\n\nPicture data stored in \"wide\" format, where different columns represent different variables of the same type. Consider this simple example:\n\n::: {#51b1cb93 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport pandas as pd\ndf = pd.DataFrame({'first': ['John', 'Mary'],\n                   'last': ['Smith', 'Doe'],\n                   'height': [5.5, 5.0],\n                   'weight': [130, 110]})\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>first</th>\n      <th>last</th>\n      <th>height</th>\n      <th>weight</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>John</td>\n      <td>Smith</td>\n      <td>5.5</td>\n      <td>130</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Mary</td>\n      <td>Doe</td>\n      <td>5.0</td>\n      <td>110</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNotice how \"height\" and \"weight\" sit in separate columns. This wide format breaks tidy principles and makes comparisons awkward when you want to plot or analyze these measurements together.\n\nThe `pandas.DataFrame.melt()` method solves this by transforming data from wide to long format. After melting, instead of separate columns for \"height\" and \"weight\", you get one column for the variable type and another for the value. Let's see it in action:\n\n::: {#2eb643ad .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\ndf_melted = df.melt(\n    id_vars=['first', 'last'],\n    var_name='quantity',\n    value_name='value'\n)\ndf_melted\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>first</th>\n      <th>last</th>\n      <th>quantity</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>John</td>\n      <td>Smith</td>\n      <td>height</td>\n      <td>5.5</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Mary</td>\n      <td>Doe</td>\n      <td>height</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>John</td>\n      <td>Smith</td>\n      <td>weight</td>\n      <td>130.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Mary</td>\n      <td>Doe</td>\n      <td>weight</td>\n      <td>110.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNow each row represents a single measurement for an individual. If you want to compare height and weight, they're in the same column format, making analysis natural. This is the essence of tidy data.\n\n### Pivot: From Long to Wide\n\nSometimes the opposite problem arises. Your data starts in \"long\" format, with a separate row for each measurement type (like \"cases\" or \"population\") for each country and year. This scatters information about a single observation across multiple rows, making it hard to see all statistics for country A in 2020 at once.\n\n::: {#b3775130 .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\n\n# Long format: each row is a different variable for country and year\ndf = pd.DataFrame({\n    'country': ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'],\n    'year': [2020, 2021, 2020, 2021, 2020, 2021, 2020, 2021],\n    'variable': ['cases', 'cases', 'population', 'population', 'cases', 'cases', 'population', 'population'],\n    'value': [100, 200, 120, 220, 130, 230, 140, 240]\n})\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>country</th>\n      <th>year</th>\n      <th>variable</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>A</td>\n      <td>2020</td>\n      <td>cases</td>\n      <td>100</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>A</td>\n      <td>2021</td>\n      <td>cases</td>\n      <td>200</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>A</td>\n      <td>2020</td>\n      <td>population</td>\n      <td>120</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>A</td>\n      <td>2021</td>\n      <td>population</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>B</td>\n      <td>2020</td>\n      <td>cases</td>\n      <td>130</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>B</td>\n      <td>2021</td>\n      <td>cases</td>\n      <td>230</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>B</td>\n      <td>2020</td>\n      <td>population</td>\n      <td>140</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>B</td>\n      <td>2021</td>\n      <td>population</td>\n      <td>240</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe `pivot()` function reshapes the data so that each observation (a country-year combination) has its measurements spread across columns. This transforms long data back to a wider, more readable format. Now each row shows all measurements for a single country and year, making analysis straightforward.\n\n### Stack and Unstack\n\nA trickier situation emerges when your data has multi-level column headers, with variables split across two or more header rows. Imagine measurements for different people and types, with test results for multiple groups all shown as columns. This nested structure makes it hard to access and visualize data cleanly.\n\n::: {#4846823b .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\n# Example: multi-level columns for two participants (P1, P2) and two attributes (A, B)\nheader = pd.MultiIndex.from_product([['P1','P2'],['A','B']])\ndf = pd.DataFrame(np.random.rand(4, 4),\n                  columns=header)\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead tr th {\n        text-align: left;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr>\n      <th></th>\n      <th colspan=\"2\" halign=\"left\">P1</th>\n      <th colspan=\"2\" halign=\"left\">P2</th>\n    </tr>\n    <tr>\n      <th></th>\n      <th>A</th>\n      <th>B</th>\n      <th>A</th>\n      <th>B</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.834378</td>\n      <td>0.846789</td>\n      <td>0.815770</td>\n      <td>0.866170</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.212554</td>\n      <td>0.130223</td>\n      <td>0.411592</td>\n      <td>0.883559</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.163426</td>\n      <td>0.127180</td>\n      <td>0.483202</td>\n      <td>0.347016</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.596388</td>\n      <td>0.458607</td>\n      <td>0.698158</td>\n      <td>0.199185</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe `stack()` method solves this by converting one level of column headers into a row index, transforming wide data to long. Now each row represents a single measurement, and all values of the same variable sit together in one column. The `unstack()` method does the reverse, spreading data back out from the index into columns.\n\nLet's see both methods in action:\n\n::: {#49b84434 .cell execution_count=5}\n``` {.python .cell-code}\ndf.stack(future_stack=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th></th>\n      <th>P1</th>\n      <th>P2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th rowspan=\"2\" valign=\"top\">0</th>\n      <th>A</th>\n      <td>0.834378</td>\n      <td>0.815770</td>\n    </tr>\n    <tr>\n      <th>B</th>\n      <td>0.846789</td>\n      <td>0.866170</td>\n    </tr>\n    <tr>\n      <th rowspan=\"2\" valign=\"top\">1</th>\n      <th>A</th>\n      <td>0.212554</td>\n      <td>0.411592</td>\n    </tr>\n    <tr>\n      <th>B</th>\n      <td>0.130223</td>\n      <td>0.883559</td>\n    </tr>\n    <tr>\n      <th rowspan=\"2\" valign=\"top\">2</th>\n      <th>A</th>\n      <td>0.163426</td>\n      <td>0.483202</td>\n    </tr>\n    <tr>\n      <th>B</th>\n      <td>0.127180</td>\n      <td>0.347016</td>\n    </tr>\n    <tr>\n      <th rowspan=\"2\" valign=\"top\">3</th>\n      <th>A</th>\n      <td>0.596388</td>\n      <td>0.698158</td>\n    </tr>\n    <tr>\n      <th>B</th>\n      <td>0.458607</td>\n      <td>0.199185</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#f10e4290 .cell execution_count=6}\n``` {.python .cell-code}\ndf.stack(future_stack=True).unstack()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead tr th {\n        text-align: left;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr>\n      <th></th>\n      <th colspan=\"2\" halign=\"left\">P1</th>\n      <th colspan=\"2\" halign=\"left\">P2</th>\n    </tr>\n    <tr>\n      <th></th>\n      <th>A</th>\n      <th>B</th>\n      <th>A</th>\n      <th>B</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.834378</td>\n      <td>0.846789</td>\n      <td>0.815770</td>\n      <td>0.866170</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.212554</td>\n      <td>0.130223</td>\n      <td>0.411592</td>\n      <td>0.883559</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.163426</td>\n      <td>0.127180</td>\n      <td>0.483202</td>\n      <td>0.347016</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.596388</td>\n      <td>0.458607</td>\n      <td>0.698158</td>\n      <td>0.199185</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "tidy-data_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}