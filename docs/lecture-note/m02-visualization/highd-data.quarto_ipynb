{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"High-Dimensional Data Visualization\"\n",
        "jupyter: advnetsci\n",
        "execute:\n",
        "    enabled: true\n",
        "---\n",
        "\n",
        "Imagine you're analyzing data with 50 features per observation: gene expression levels, user behavior metrics, or environmental measurements. You want to understand the patterns in your data. How do different observations relate to each other? Are there clusters? Outliers?\n",
        "\n",
        "You can't plot 50 dimensions directly. Our visual system lives in three dimensions (or really, two dimensions on a screen). This creates a fundamental challenge: **how do you visualize data that lives in spaces you cannot see?**\n",
        "\n",
        "The answer is dimensionality reduction---projecting high-dimensional data into 2 or 3 dimensions while preserving important structure. But here's the critical question: **what structure matters?**\n",
        "\n",
        "Different methods preserve different aspects of your data. Some preserve global structure (how groups relate to each other across the entire dataset). Others preserve local structure (which points are nearest neighbors). Understanding these trade-offs is essential for choosing the right method---and for not being misled by beautiful but misleading visualizations.\n",
        "\n",
        "# The Curse of Dimensionality\n",
        "\n",
        "Before we dive into methods, we need to understand what makes high-dimensional data fundamentally different.\n",
        "\n",
        "In high dimensions, **everything is far from everything else**. This sounds paradoxical, but it's mathematically inevitable. As dimensions increase, the volume of space grows exponentially, and data points become increasingly sparse.\n",
        "\n",
        "Consider this: in 1D, if you have 10 points uniformly distributed in [0, 1], the average distance between neighbors is about 0.1. To maintain the same density in 2D, you need 100 points. In 3D, you need 1,000 points. In 10D, you need 10 billion points.\n",
        "\n",
        "Even stranger: in high dimensions, **all distances become similar**. The nearest and farthest neighbors become roughly equidistant. This makes many of our intuitions about \"closeness\" break down."
      ],
      "id": "ff57e947"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 10,
        "fig-height": 5
      },
      "source": [
        "#| fig-cap: As dimensions increase, the ratio of farthest to nearest distance approaches 1\n",
        "#| code-fold: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import pandas as pd\n",
        "from sklearn.metrics.pairwise import euclidean_distances\n",
        "\n",
        "sns.set_style(\"white\")\n",
        "np.random.seed(42)\n",
        "\n",
        "# Calculate distance ratio across dimensions\n",
        "dimensions = [2, 5, 10, 20, 50, 100, 200]\n",
        "n_samples = 100\n",
        "ratios = []\n",
        "\n",
        "for d in dimensions:\n",
        "    # Generate random data\n",
        "    X = np.random.randn(n_samples, d)\n",
        "    # Calculate all pairwise distances\n",
        "    distances = euclidean_distances(X)\n",
        "    # For each point, find nearest and farthest (excluding self)\n",
        "    np.fill_diagonal(distances, np.inf)  # Ignore self-distance\n",
        "    nearest = distances.min(axis=1)\n",
        "    # For \"farthest,\" ignore inf (self-distance), so set inf entries to -1 and use argmax\n",
        "    temp = distances.copy()\n",
        "    temp[temp == np.inf] = -1  # Now maximum is truly among finite values\n",
        "    farthest = temp.max(axis=1)\n",
        "    # Calculate ratio\n",
        "    ratio = nearest / farthest\n",
        "    ratios.append(ratio)\n",
        "\n",
        "# Plot\n",
        "sns.set(font_scale=2.0)\n",
        "sns.set_style(\"white\")\n",
        "\n",
        "blue, red = sns.color_palette('muted', 2)\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 5))\n",
        "positions = range(len(dimensions))\n",
        "bp = ax.boxplot(ratios, positions=positions, widths=0.6, patch_artist=True,\n",
        "                boxprops=dict(facecolor=\"#f2f2f2\", alpha=0.7))\n",
        "ax.set_xticklabels(dimensions)\n",
        "ax.set_xlabel('Number of Dimensions')\n",
        "ax.set_ylabel('Nearest Distance / Farthest Distance')\n",
        "ax.set_title('The Curse of Dimensionality: All Points Become Equidistant')\n",
        "ax.axhline(y=1.0, color=red, linestyle='--', alpha=0.5, label='Equal distances')\n",
        "ax.legend(frameon=False)\n",
        "sns.despine()"
      ],
      "id": "4f02b5e0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In order words, dimensionality reduction is useful not just for visualization, but also for analysis. For example, when you want to cluster data points, every point is equidistant from every other point, so you can't cluster them. By projecting the data into lower dimensions, you can remedy this curse of dimensionality.\n",
        "\n",
        "# Pairwise Scatter Plots: The Brute Force Approach\n",
        "\n",
        "When you have a **moderate number of dimensions** (roughly 3-10), you can visualize all pairwise relationships using a **scatter plot matrix** (also called a pairs plot or SPLOM)."
      ],
      "id": "a5cb135a"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 14,
        "fig-height": 14
      },
      "source": [
        "#| fig-cap: Scatter plot matrix showing all pairwise relationships in the Iris dataset\n",
        "#| code-fold: true\n",
        "# Load classic iris dataset (4 dimensions)\n",
        "from sklearn.datasets import load_iris\n",
        "\n",
        "sns.set(font_scale=1.0)\n",
        "sns.set_style(\"white\")\n",
        "\n",
        "iris = load_iris()\n",
        "iris_df = pd.DataFrame(iris.data, columns=iris.feature_names)\n",
        "iris_df['species'] = iris.target\n",
        "iris_df['species'] = iris_df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})\n",
        "\n",
        "# Create pairplot\n",
        "g = sns.pairplot(iris_df, hue='species', diag_kind='kde',\n",
        "                 plot_kws={'alpha': 0.6, 's': 50, 'edgecolor': 'white', 'linewidth': 0.5},\n",
        "                 diag_kws={'alpha': 0.7, 'linewidth': 2})\n",
        "g.fig.suptitle('Iris Dataset: All Pairwise Relationships', y=1.01)"
      ],
      "id": "fecbbb9d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The scatter plot matrix shows every possible 2D projection. The diagonal shows the univariate distribution of each feature (using KDE here), and off-diagonals show bivariate scatter plots.\n",
        "\n",
        "The problem: scatter plot matrices don't scale. With 10 variables, you have 45 unique pairwise plots---manageable but crowded. With 20 variables, you have 190 plots---overwhelming. And you're still only seeing 2D projections, never the full high-dimensional structure.\n",
        "\n",
        "This is where dimensionality reduction becomes essential.\n",
        "\n",
        "# Linear Dimensionality Reduction: PCA\n",
        "\n",
        "**Principal Component Analysis (PCA)** is a linear dimensionality reduction method that finds the directions of maximum variance in your data.\n",
        "\n",
        "Imagine you have a cloud of points in high-dimensional space. PCA asks: \"What direction captures the most variation in the data?\" This becomes the first principal component (PC1). Then it asks: \"What direction, perpendicular to the first, captures the most remaining variation?\" This becomes PC2. And so on.\n",
        "\n",
        "Mathematically, PCA finds the eigenvectors of the covariance matrix. But conceptually, it's rotating your coordinate system to align with the the highest variance directions of your data."
      ],
      "id": "bd34d4f2"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 10,
        "fig-height": 6
      },
      "source": [
        "#| fig-cap: PCA finds directions of maximum variance. PC1 captures the most variation, PC2 the next most (perpendicular to PC1).\n",
        "#| code-fold: true\n",
        "from sklearn.decomposition import PCA\n",
        "\n",
        "# Generate correlated 2D data (for visualization)\n",
        "np.random.seed(123)\n",
        "mean = [0, 0]\n",
        "cov = [[3, 2], [2, 2]]\n",
        "data_2d = np.random.multivariate_normal(mean, cov, 300)\n",
        "\n",
        "# Fit PCA\n",
        "pca = PCA(n_components=2)\n",
        "pca.fit(data_2d)\n",
        "\n",
        "colors = [\"#f2f2f2\", sns.color_palette('muted')[0], sns.color_palette('muted')[3]]\n",
        "\n",
        "# Plot original data with principal components\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "ax.scatter(data_2d[:, 0], data_2d[:, 1], alpha=0.9, s=50, color=colors[0], edgecolors='k', linewidth=0.5)\n",
        "\n",
        "# Draw principal components as arrows\n",
        "origin = pca.mean_\n",
        "for i, (component, variance) in enumerate(zip(pca.components_, pca.explained_variance_)):\n",
        "    direction = component * np.sqrt(variance) * 3  # Scale for visibility\n",
        "    ax.arrow(origin[0], origin[1], direction[0], direction[1],\n",
        "             head_width=0.3, head_length=0.3, fc=colors[i+1], ec=colors[i+1], linewidth=3,\n",
        "             label=f'PC{i+1} ({variance/pca.explained_variance_.sum()*100:.1f}%)')\n",
        "\n",
        "ax.set_xlabel('Original X')\n",
        "ax.set_ylabel('Original Y')\n",
        "ax.set_title('Principal Components: Directions of Maximum Variance')\n",
        "ax.legend()\n",
        "ax.axis('equal')\n",
        "sns.despine()"
      ],
      "id": "c7c350ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "PC1 (orange arrow) points along the direction of greatest spread. PC2 (green arrow) is perpendicular and captures the remaining variation.\n",
        "\n",
        "The percentage in parentheses shows how much variance each component explains. If PC1 explains 90% of variance, then projecting onto just PC1 preserves most of your data's structure.\n",
        "\n",
        "## Applying PCA to Iris\n",
        "\n",
        "Let's apply PCA to the 4-dimensional Iris dataset:"
      ],
      "id": "68d4c56f"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 14,
        "fig-height": 6
      },
      "source": [
        "#| fig-cap: PCA projection of Iris dataset to 2D preserves the separation between species\n",
        "#| code-fold: true\n",
        "# Prepare data\n",
        "X = iris.data\n",
        "y = iris.target\n",
        "\n",
        "# Standardize (important for PCA!)\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "scaler = StandardScaler()\n",
        "X_scaled = scaler.fit_transform(X)\n",
        "\n",
        "# Apply PCA\n",
        "pca = PCA(n_components=2)\n",
        "X_pca = pca.fit_transform(X_scaled)\n",
        "\n",
        "# Create DataFrame for plotting\n",
        "pca_df = pd.DataFrame(X_pca, columns=['PC1', 'PC2'])\n",
        "pca_df['species'] = iris.target_names[y]\n",
        "\n",
        "# Plot\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n",
        "\n",
        "# Left: PCA projection\n",
        "for species, color in zip(['setosa', 'versicolor', 'virginica'], sns.color_palette('muted', 3)):\n",
        "    mask = pca_df['species'] == species\n",
        "    axes[0].scatter(pca_df.loc[mask, 'PC1'], pca_df.loc[mask, 'PC2'],\n",
        "                   label=species, alpha=0.7, s=50, color=color, edgecolors='white', linewidth=0.5)\n",
        "axes[0].set_xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}% variance)')\n",
        "axes[0].set_ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}% variance)')\n",
        "axes[0].set_title('PCA Projection of Iris Dataset')\n",
        "axes[0].legend()\n",
        "sns.despine(ax=axes[0])\n",
        "\n",
        "# Right: Variance explained\n",
        "variances = pca.explained_variance_ratio_\n",
        "axes[1].bar([1, 2], variances, color=sns.color_palette('muted', 2), alpha=0.7)\n",
        "axes[1].set_xlabel('Principal Component')\n",
        "axes[1].set_ylabel('Variance Explained')\n",
        "axes[1].set_title('Variance Explained by Each Component')\n",
        "axes[1].set_xticks([1, 2])\n",
        "axes[1].set_xticklabels(['PC1', 'PC2'])\n",
        "for i, v in enumerate(variances):\n",
        "    axes[1].text(i+1, v+0.01, f'{v*100:.1f}%', ha='center', va='bottom', fontsize=11)\n",
        "sns.despine(ax=axes[1])\n",
        "\n",
        "plt.tight_layout()"
      ],
      "id": "2b26625d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "PC1 and PC2 together explain over 95% of the variance in the 4D dataset. The 2D projection preserves the main structure: setosa is well-separated, while versicolor and virginica have some overlap.\n",
        "\n",
        "::: {.column-margin}\n",
        "\n",
        "**Always standardize before PCA!** If features have different units or scales, PCA will be dominated by high-variance features. Standardization (zero mean, unit variance) ensures all features contribute fairly.\n",
        "\n",
        ":::\n",
        "\n",
        "# Non-Linear Dimensionality Reduction: MDS\n",
        "\n",
        "**Multidimensional Scaling (MDS)** takes a different approach: instead of finding directions of maximum variance, it tries to **preserve distances between points**.\n",
        "\n",
        "You give MDS a distance matrix---the distance between every pair of points in high-dimensional space---and it finds a low-dimensional configuration where those distances are preserved as well as possible.\n",
        "\n",
        "Think of it like arranging cities on a map. You know the distance between every pair of cities, but not their coordinates. MDS finds positions that preserve those distances.\n",
        "\n",
        "Mathematically, MDS minimizes **stress**: the difference between high-dimensional distances and low-dimensional distances. Classical MDS has a closed-form solution (like PCA), but more flexible variants use iterative optimization."
      ],
      "id": "4f84a9a6"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 14,
        "fig-height": 6
      },
      "source": [
        "#| fig-cap: MDS vs PCA on Iris dataset. MDS preserves distances better but looks similar to PCA for this dataset.\n",
        "#| code-fold: true\n",
        "from sklearn.manifold import MDS\n",
        "\n",
        "# Suppress FutureWarning about n_init in MDS\n",
        "import warnings\n",
        "mds = MDS(n_components=2, random_state=42, n_init=1)\n",
        "X_mds = mds.fit_transform(X_scaled)\n",
        "\n",
        "# Create DataFrame\n",
        "mds_df = pd.DataFrame(X_mds, columns=['MDS1', 'MDS2'])\n",
        "mds_df['species'] = iris.target_names[y]\n",
        "\n",
        "# Plot both\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n",
        "\n",
        "# PCA\n",
        "for species, color in zip(['setosa', 'versicolor', 'virginica'], sns.color_palette('muted', 3)):\n",
        "    mask = pca_df['species'] == species\n",
        "    axes[0].scatter(pca_df.loc[mask, 'PC1'], pca_df.loc[mask, 'PC2'],\n",
        "                   label=species, alpha=0.7, s=50, color=color, edgecolors='white', linewidth=0.5)\n",
        "axes[0].set_xlabel('PC1')\n",
        "axes[0].set_ylabel('PC2')\n",
        "axes[0].set_title('PCA: Maximizes Variance')\n",
        "axes[0].legend()\n",
        "sns.despine(ax=axes[0])\n",
        "\n",
        "# MDS\n",
        "for species, color in zip(['setosa', 'versicolor', 'virginica'], sns.color_palette('muted', 3)):\n",
        "    mask = mds_df['species'] == species\n",
        "    axes[1].scatter(mds_df.loc[mask, 'MDS1'], mds_df.loc[mask, 'MDS2'],\n",
        "                   label=species, alpha=0.7, s=50, color=color, edgecolors='white', linewidth=0.5)\n",
        "axes[1].set_xlabel('MDS1')\n",
        "axes[1].set_ylabel('MDS2')\n",
        "axes[1].set_title('MDS: Preserves Distances')\n",
        "axes[1].legend()\n",
        "sns.despine(ax=axes[1])\n",
        "\n",
        "plt.tight_layout()"
      ],
      "id": "bf033baa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "For the Iris dataset, PCA and MDS look very similar. This is because Iris data is fairly linear---the relationships between features don't involve complex curves or non-linear structures.\n",
        "\n",
        "::: {.column-margin}\n",
        "\n",
        "**Why MDS isn't perfect here:** The S-curve has points that are close in Euclidean distance (across the bend) but far apart along the curved surface. MDS tries to preserve both types of distances, creating a compromise that partially straightens the curve but doesn't fully recover the underlying smooth 1D gradient.\n",
        "\n",
        ":::\n",
        "\n",
        "# Isomap: Preserving Geodesic Distances\n",
        "\n",
        "MDS preserves Euclidean distances---straight-line distances through space. But for curved manifolds, what matters is the **geodesic distance**: the distance along the surface.\n",
        "\n",
        "**Isomap** (Isometric Mapping) addresses this by approximating geodesic distances using the neighborhood graph:\n",
        "\n",
        "1. **Build a neighborhood graph**: Connect each point to its k nearest neighbors\n",
        "2. **Compute shortest paths**: The geodesic distance between points is approximated by the shortest path through this graph\n",
        "3. **Apply classical MDS**: Use MDS on these geodesic distances instead of Euclidean distances\n",
        "\n",
        "Think of it like this: MDS measures distance \"as the crow flies,\" while Isomap measures distance \"as you walk along the surface.\""
      ],
      "id": "c8b64c4e"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 14,
        "fig-height": 6
      },
      "source": [
        "#| fig-cap: Isomap uses geodesic distances (along the surface) instead of Euclidean distances (through space), better recovering the S-curve structure\n",
        "#| code-fold: true\n",
        "from sklearn.manifold import Isomap\n",
        "```{python}\n",
        "#| fig-cap: \"MDS can reveal non-linear structure that PCA misses. S-curve dataset shown.\"\n",
        "#| fig-width: 14\n",
        "#| fig-height: 6\n",
        "#| code-fold: true\n",
        "from sklearn.datasets import make_s_curve\n",
        "\n",
        "# Generate S-curve data (a 2D manifold embedded in 3D)\n",
        "n_samples = 1000\n",
        "X_scurve, color = make_s_curve(n_samples, noise=0.1, random_state=42)"
      ],
      "id": "8ff3c50c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Apply Isomap\n",
        "isomap = Isomap(n_components=2, n_neighbors=10)\n",
        "X_scurve_isomap = isomap.fit_transform(X_scurve)\n",
        "\n",
        "# Plot MDS vs Isomap\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n",
        "\n",
        "# MDS\n",
        "axes[0].scatter(X_scurve_mds[:, 0], X_scurve_mds[:, 1], c=color,\n",
        "                cmap='viridis', alpha=0.6, s=20)\n",
        "axes[0].set_xlabel('MDS1')\n",
        "axes[0].set_ylabel('MDS2')\n",
        "axes[0].set_title('MDS: Global Euclidean Distances')\n",
        "sns.despine(ax=axes[0])\n",
        "\n",
        "# Isomap\n",
        "axes[1].scatter(X_scurve_isomap[:, 0], X_scurve_isomap[:, 1], c=color,\n",
        "                cmap='viridis', alpha=0.6, s=20)\n",
        "axes[1].set_xlabel('Isomap1')\n",
        "axes[1].set_ylabel('Isomap2')\n",
        "axes[1].set_title('Isomap: Geodesic Distances')\n",
        "sns.despine(ax=axes[1])\n",
        "\n",
        "plt.tight_layout()\n",
        "```\n",
        "\n",
        "Isomap successfully \"straightens\" the S-curve because it respects the manifold structure. By computing distances along the neighborhood graph, it avoids the shortcuts across the bend that confused MDS.\n",
        "\n",
        "**The key parameter: n_neighbors**\n",
        "- **Too few neighbors**: Graph becomes disconnected, distances become infinite\n",
        "- **Too many neighbors**: You create shortcuts across the manifold, reverting to MDS-like behavior\n",
        "- **Just right (5-15 typically)**: Captures local manifold structure\n",
        "\n",
        "::: {.callout-note}\n",
        "## Global vs Local: A fundamental trade-off\n",
        "\n",
        "We now see two extremes:\n",
        "- **MDS**: Preserves all pairwise distances globally (works on linear/convex data)\n",
        "- **Isomap**: Preserves geodesic distances using local neighborhoods (works on curved manifolds)\n",
        "\n",
        "But what if we **only care about local structure**? What if global relationships don't matter?\n",
        ":::\n",
        "\n",
        "# Modern Non-Linear Methods: t-SNE and UMAP\n",
        "\n",
        "Both **t-SNE** (t-Distributed Stochastic Neighbor Embedding) and **UMAP** (Uniform Manifold Approximation and Projection) take a middle ground between MDS's global approach and Isomap's geodesic approach: they **prioritize local structure** while allowing some flexibility in global positioning.\n",
        "\n",
        "The key insight: for visualization, we often care most about **which points are neighbors**. Whether distant clusters are placed left vs right, or how far apart they are, matters less than preserving the local neighborhood relationships within and between clusters.\n",
        "\n",
        "## How t-SNE works\n",
        "\n",
        "t-SNE converts distances into similarity probabilities and preserves these local relationships:\n",
        "\n",
        "1. **In high dimensions**: Define probability $p_{ij}$ that point $i$ picks point $j$ as a neighbor (based on Gaussian distance)\n",
        "2. **In low dimensions**: Define similar probability $q_{ij}$ using a t-distribution with heavy tails\n",
        "3. **Optimize**: Move points in 2D to make $q_{ij}$ match $p_{ij}$ (minimize KL divergence)\n",
        "\n",
        "The t-distribution's heavy tails are clever: they let well-separated clusters spread out in 2D without overlapping, while keeping local neighborhoods tight."
      ],
      "id": "67c28eba"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 15,
        "fig-height": 5
      },
      "source": [
        "#| fig-cap: Comparing global, geodesic, and local approaches on the S-curve\n",
        "#| code-fold: true\n",
        "from sklearn.manifold import TSNE\n",
        "\n",
        "# Apply t-SNE\n",
        "tsne = TSNE(n_components=2, random_state=42, perplexity=30)\n",
        "X_scurve_tsne = tsne.fit_transform(X_scurve)\n",
        "\n",
        "# Plot all three methods\n",
        "fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n",
        "\n",
        "# MDS - Global Euclidean distances\n",
        "axes[0].scatter(X_scurve_mds[:, 0], X_scurve_mds[:, 1], c=color,\n",
        "                cmap='viridis', alpha=0.6, s=20)\n",
        "axes[0].set_xlabel('MDS1')\n",
        "axes[0].set_ylabel('MDS2')\n",
        "axes[0].set_title('MDS: Global Distances')\n",
        "sns.despine(ax=axes[0])\n",
        "\n",
        "# Isomap - Geodesic distances\n",
        "axes[1].scatter(X_scurve_isomap[:, 0], X_scurve_isomap[:, 1], c=color,\n",
        "                cmap='viridis', alpha=0.6, s=20)\n",
        "axes[1].set_xlabel('Isomap1')\n",
        "axes[1].set_ylabel('Isomap2')\n",
        "axes[1].set_title('Isomap: Geodesic Distances')\n",
        "sns.despine(ax=axes[1])\n",
        "\n",
        "# t-SNE - Local neighborhoods\n",
        "axes[2].scatter(X_scurve_tsne[:, 0], X_scurve_tsne[:, 1], c=color,\n",
        "                cmap='viridis', alpha=0.6, s=20)\n",
        "axes[2].set_xlabel('t-SNE1')\n",
        "axes[2].set_ylabel('t-SNE2')\n",
        "axes[2].set_title('t-SNE: Local Structure')\n",
        "sns.despine(ax=axes[2])\n",
        "\n",
        "plt.tight_layout()"
      ],
      "id": "8e318f66",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "All three methods successfully straighten the S-curve, but through different philosophies: MDS compromises between all distances, Isomap follows the manifold globally, and t-SNE focuses on preserving neighborhoods.\n",
        "\n",
        "## Key parameter: Perplexity\n",
        "\n",
        "**Perplexity** (typically 30-50) controls the effective neighborhood size. Too low fragments clusters; too high loses local detail.\n",
        "\n",
        "## What t-SNE preserves (and what it doesn't)\n",
        "\n",
        "t-SNE is powerful but has important limitations:\n",
        "\n",
        "**What t-SNE preserves:**\n",
        "- \u0013 **Local structure**: Points that are neighbors in high dimensions stay neighbors in 2D\n",
        "- \u0013 **Clusters**: Well-separated groups remain separated\n",
        "- \u0013 **Relative relationships within neighborhoods**: If A is closer to B than to C locally, this is preserved\n",
        "\n",
        "**What t-SNE does NOT preserve:**\n",
        "- \u0017 **Distances**: The actual distance between points is not meaningful\n",
        "- \u0017 **Global structure**: The relative position of distant clusters is arbitrary\n",
        "- \u0017 **Cluster sizes**: Large clusters may appear smaller, and vice versa\n",
        "- \u0017 **Density**: Tight clusters may be spread out; sparse regions may appear dense\n",
        "\n",
        "::: {.callout-warning}\n",
        "## Don't over-interpret t-SNE!\n",
        "\n",
        "**You cannot conclude** from a t-SNE plot:\n",
        "- \"Cluster A is twice as far from B as from C\" (distances are not preserved)\n",
        "- \"Cluster A is twice the size of B\" (sizes are not preserved)\n",
        "- \"The data has exactly 5 clusters\" (apparent clusters may be visualization artifacts)\n",
        "\n",
        "**You can conclude:**\n",
        "- \"These points form a distinct group separate from others\"\n",
        "- \"These points are more similar to each other than to distant points\"\n",
        "- \"The data has local structure and is not uniformly random\"\n",
        ":::\n",
        "\n",
        "## Applying t-SNE to real data\n",
        "\n",
        "Let's apply t-SNE to a more realistic high-dimensional dataset---the MNIST digits dataset, which has 784 dimensions (28�28 pixel images):"
      ],
      "id": "39b7e48e"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 12,
        "fig-height": 10
      },
      "source": [
        "#| fig-cap: t-SNE visualization of MNIST digits (784 dimensions � 2D). Each color represents a digit class.\n",
        "#| code-fold: true\n",
        "from sklearn.datasets import load_digits\n",
        "\n",
        "# Load digits dataset (8x8 images, 64 dimensions - a smaller version of MNIST)\n",
        "digits = load_digits()\n",
        "X_digits = digits.data\n",
        "y_digits = digits.target\n",
        "\n",
        "# Take a subset for speed (t-SNE is slow on large datasets)\n",
        "np.random.seed(42)\n",
        "indices = np.random.choice(len(X_digits), size=1000, replace=False)\n",
        "X_subset = X_digits[indices]\n",
        "y_subset = y_digits[indices]\n",
        "\n",
        "# Apply t-SNE\n",
        "tsne_digits = TSNE(n_components=2, random_state=42, perplexity=40)\n",
        "X_digits_tsne = tsne_digits.fit_transform(X_subset)\n",
        "\n",
        "# Plot\n",
        "fig, ax = plt.subplots(figsize=(12, 10))\n",
        "scatter = ax.scatter(X_digits_tsne[:, 0], X_digits_tsne[:, 1],\n",
        "                     c=y_subset, cmap='tab10', alpha=0.7, s=30)\n",
        "ax.set_xlabel('t-SNE1')\n",
        "ax.set_ylabel('t-SNE2')\n",
        "ax.set_title('t-SNE Visualization of Handwritten Digits (64D � 2D)')\n",
        "cbar = plt.colorbar(scatter, ax=ax, ticks=range(10))\n",
        "cbar.set_label('Digit Class')\n",
        "sns.despine()"
      ],
      "id": "29be2d1e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The t-SNE projection beautifully separates most digit classes. Digits that look similar (like 3, 5, and 8, or 4 and 9) cluster near each other, while visually distinct digits (like 0 and 1) are well separated.\n",
        "\n",
        "This demonstrates t-SNE's power: from 64 dimensions with no explicit information about what makes digits similar, t-SNE discovers the perceptual structure of handwritten digits.\n",
        "\n",
        "::: {.column-margin}\n",
        "\n",
        "**t-SNE is stochastic**: Different runs produce different layouts (though cluster structure remains consistent). Always check multiple runs with different random seeds, especially for important scientific conclusions.\n",
        "\n",
        ":::\n",
        "\n",
        "# UMAP: A Faster Alternative\n",
        "\n",
        "**Uniform Manifold Approximation and Projection (UMAP)** is a newer method (2018) that has become popular as an alternative to t-SNE. Like t-SNE, UMAP preserves local structure, but it's based on different mathematical foundations (manifold learning and topological data analysis).\n",
        "\n",
        "## UMAP vs t-SNE\n",
        "\n",
        "**Advantages of UMAP:**\n",
        "- **Faster**: Can be 10-100� faster than t-SNE on large datasets\n",
        "- **Scales better**: Works well on datasets with millions of points\n",
        "- **Better global structure**: Preserves more global relationships than t-SNE\n",
        "- **Theoretically grounded**: Based on Riemannian geometry and fuzzy topology\n",
        "\n",
        "**Trade-offs:**\n",
        "- Less battle-tested than t-SNE (newer method)\n",
        "- More hyperparameters to tune (though defaults work well)\n",
        "- Can produce similar-looking results to t-SNE, so choice often comes down to speed"
      ],
      "id": "fe9d3e8f"
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-width": 14,
        "fig-height": 6
      },
      "source": [
        "#| fig-cap: UMAP vs t-SNE on digits dataset. UMAP often preserves more global structure while being much faster.\n",
        "#| code-fold: true\n",
        "import umap\n",
        "\n",
        "# Apply UMAP\n",
        "umap_model = umap.UMAP(n_components=2, random_state=42, n_neighbors=30)\n",
        "X_digits_umap = umap_model.fit_transform(X_subset)\n",
        "\n",
        "# Plot comparison\n",
        "fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n",
        "\n",
        "# t-SNE\n",
        "scatter = axes[0].scatter(X_digits_tsne[:, 0], X_digits_tsne[:, 1],\n",
        "                          c=y_subset, cmap='tab10', alpha=0.7, s=30)\n",
        "axes[0].set_xlabel('t-SNE1')\n",
        "axes[0].set_ylabel('t-SNE2')\n",
        "axes[0].set_title('t-SNE')\n",
        "sns.despine(ax=axes[0])\n",
        "\n",
        "# UMAP\n",
        "scatter = axes[1].scatter(X_digits_umap[:, 0], X_digits_umap[:, 1],\n",
        "                          c=y_subset, cmap='tab10', alpha=0.7, s=30)\n",
        "axes[1].set_xlabel('UMAP1')\n",
        "axes[1].set_ylabel('UMAP2')\n",
        "axes[1].set_title('UMAP')\n",
        "cbar = plt.colorbar(scatter, ax=axes[1], ticks=range(10))\n",
        "cbar.set_label('Digit Class')\n",
        "sns.despine(ax=axes[1])\n",
        "\n",
        "plt.tight_layout()"
      ],
      "id": "7dd506b7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Both methods reveal similar cluster structure, but UMAP tends to space clusters more evenly and preserve more of the global topology. Notice how UMAP places similar digits (3, 5, 8) in a connected region, suggesting they share underlying structure.\n",
        "\n",
        "## When to use UMAP\n",
        "\n",
        "Use UMAP when:\n",
        "- You have very large datasets (>10,000 points) where t-SNE is slow\n",
        "- You want to preserve more global structure\n",
        "- You're doing exploratory analysis and want fast iteration\n",
        "- You need to project new data onto an existing embedding (UMAP supports this, t-SNE doesn't easily)\n",
        "\n",
        "Stick with t-SNE when:\n",
        "- You need the most established method with extensive literature\n",
        "- You're working with moderate-sized datasets where speed isn't critical\n",
        "- You're replicating published work that used t-SNE\n",
        "\n",
        "# The Bigger Picture: Choosing the Right Method\n",
        "\n",
        "Dimensionality reduction is not a one-size-fits-all solution. Different methods make different trade-offs:\n",
        "\n",
        "| Method | Preserves | Speed | Scalability | When to use |\n",
        "|--------|-----------|-------|-------------|-------------|\n",
        "| **Scatter plot matrix** | Everything (2D projections) | Fast | 3-10 dimensions | Exploring moderate-dimensional data |\n",
        "| **PCA** | Global variance | Very fast | Excellent (1000s of dims) | Linear structure, interpretability needed |\n",
        "| **MDS** | All distances | Slow | Poor (100s of points) | Distance preservation critical |\n",
        "| **t-SNE** | Local structure | Slow | Moderate (10,000s of points) | Revealing clusters, local relationships |\n",
        "| **UMAP** | Local + some global | Fast | Excellent (millions of points) | Large datasets, faster alternative to t-SNE |\n",
        "\n",
        "**A practical workflow:**\n",
        "\n",
        "1. **Start with PCA**: Always run PCA first. It's fast, interpretable, and if it works well, you're done. Check how much variance the first 2-3 components explain.\n",
        "\n",
        "2. **Check pairwise plots** (if feasible): If you have <10 dimensions, look at scatter plot matrices to understand pairwise relationships.\n",
        "\n",
        "3. **Try t-SNE or UMAP** if:\n",
        "   - PCA doesn't reveal clear structure (first 2 PCs explain <50% variance)\n",
        "   - You suspect non-linear relationships\n",
        "   - You want to find clusters\n",
        "\n",
        "4. **Validate your findings**: Don't trust a single visualization. Try:\n",
        "   - Different random seeds (for t-SNE/UMAP)\n",
        "   - Different hyperparameters (perplexity, number of neighbors)\n",
        "   - Different methods (does t-SNE and PCA agree?)\n",
        "   - Statistical tests on apparent clusters\n",
        "\n",
        "::: {.callout-important}\n",
        "## Beware of visualization artifacts\n",
        "\n",
        "Dimensionality reduction can create apparent patterns that don't exist in the original data:\n",
        "- **Spurious clusters**: t-SNE can split continuous data into false clusters\n",
        "- **Missing relationships**: Two clusters might be connected in high dimensions but appear separated in 2D\n",
        "- **Misleading distances**: Distance and size in t-SNE/UMAP are not meaningful\n",
        "\n",
        "**Always validate** important findings with statistical tests or domain knowledge. A beautiful t-SNE plot is a starting point for investigation, not a final conclusion.\n",
        ":::\n",
        "\n",
        "Visualizing high-dimensional data is as much art as science. The goal is not to find \"the true projection\"---there is no single true way to flatten high-dimensional space onto a page. The goal is to **reveal structure that helps you understand your data and ask better questions**.\n",
        "\n",
        "As data scientist Jake VanderPlas wrote: \"Dimensionality reduction is a form of lossy compression. The question is not whether you lose information---you always do---but whether you lose the information you care about.\""
      ],
      "id": "d0b61dc6"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "advnetsci",
      "language": "python",
      "display_name": "Python (advnetsci)",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/advnetsci"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}