---
title: "High-Dimensional Data Visualization"
execute:
    enabled: true
---

::: {.callout-note title="What you'll learn in this module"}
This module introduces dimensionality reduction, a fundamental technique for visualizing and understanding high-dimensional data.

You'll learn:

- What **the curse of dimensionality** means and why high-dimensional space is counterintuitive.
- How to use **PCA** to preserve global variance structure in linear projections.
- The difference between **local methods** (t-SNE, UMAP) and **global methods** (MDS, Isomap).
- How to **choose the right method** for your data and avoid misleading visualizations.
:::

Imagine you're analyzing data with 50 features per observation. Gene expression levels, user behavior metrics, environmental measurements. You want to understand the patterns. How do different observations relate to each other? Are there clusters? Outliers?

Here's the fundamental problem: you can't plot 50 dimensions directly. Our visual system lives in three dimensions, or really two on a screen. How do you visualize data that lives in spaces you cannot see?

The answer is dimensionality reduction. This technique projects high-dimensional data into 2 or 3 dimensions while preserving important structure. But here's the critical question: what structure matters?

Different methods preserve different aspects of your data. Some preserve global structure, showing how groups relate across the entire dataset. Others preserve local structure, highlighting nearest neighbors. Understanding these trade-offs is essential for choosing the right method and avoiding beautiful but misleading visualizations.

## The Curse of Dimensionality

Let's talk about what makes high-dimensional data fundamentally different.

In high dimensions, everything is far from everything else. This sounds paradoxical, but it's mathematically inevitable. As dimensions increase, the volume of space grows exponentially, and data points become increasingly sparse.

Consider this simple fact. In 1D, if you have 10 points uniformly distributed in [0, 1], the average distance between neighbors is about 0.1. To maintain the same density in 2D, you need 100 points. In 3D, you need 1,000 points. In 10D, you need 10 billion points.

Even stranger is what happens to distances. In high dimensions, all distances become similar. The nearest and farthest neighbors become roughly equidistant. This makes many of our intuitions about "closeness" break down.

```{python}
#| fig-cap: "As dimensions increase, the ratio of farthest to nearest distance approaches 1"
#| fig-width: 10
#| fig-height: 5
#| code-fold: true
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from sklearn.metrics.pairwise import euclidean_distances

sns.set_style("white")
np.random.seed(42)

# Calculate distance ratio across dimensions
dimensions = [2, 5, 10, 20, 50, 100, 200]
n_samples = 100
ratios = []

for d in dimensions:
    # Generate random data
    X = np.random.randn(n_samples, d)
    # Calculate all pairwise distances
    distances = euclidean_distances(X)
    # For each point, find nearest and farthest (excluding self)
    np.fill_diagonal(distances, np.inf)  # Ignore self-distance
    nearest = distances.min(axis=1)
    # For "farthest," ignore inf (self-distance), so set inf entries to -1 and use argmax
    temp = distances.copy()
    temp[temp == np.inf] = -1  # Now maximum is truly among finite values
    farthest = temp.max(axis=1)
    # Calculate ratio
    ratio = nearest / farthest
    ratios.append(ratio)

# Plot
sns.set(font_scale=2.0)
sns.set_style("white")

blue, red = sns.color_palette('muted', 2)

fig, ax = plt.subplots(figsize=(10, 5))
positions = range(len(dimensions))
bp = ax.boxplot(ratios, positions=positions, widths=0.6, patch_artist=True,
                boxprops=dict(facecolor="#f2f2f2", alpha=0.7))
ax.set_xticklabels(dimensions)
ax.set_xlabel('Number of Dimensions')
ax.set_ylabel('Nearest Distance / Farthest Distance')
ax.set_title('The Curse of Dimensionality: All Points Become Equidistant')
ax.axhline(y=1.0, color=red, linestyle='--', alpha=0.5, label='Equal distances')
ax.legend(frameon=False)
sns.despine()
```

The plot shows a striking pattern. As dimensions increase, the ratio of nearest to farthest distance gets closer to 1. At 200 dimensions, nearly every point is equally far from every other point.

Why does this matter? When you want to cluster data points, every point becomes equidistant from every other point, making clustering impossible. By projecting the data into lower dimensions, you can remedy this problem. This is why dimensionality reduction matters for analysis, not just visualization.

## Pairwise Scatter Plots: The Brute Force Approach

When you have a moderate number of dimensions (roughly 3 to 10), you can visualize all pairwise relationships using a scatter plot matrix, also called a pairs plot or SPLOM.

```{python}
#| fig-cap: "Scatter plot matrix showing all pairwise relationships in the Iris dataset"
#| fig-width: 14
#| fig-height: 14
#| code-fold: true
# Load classic iris dataset (4 dimensions)
from sklearn.datasets import load_iris

sns.set(font_scale=1.0)
sns.set_style("white")

iris = load_iris()
iris_df = pd.DataFrame(iris.data, columns=iris.feature_names)
iris_df['species'] = iris.target
iris_df['species'] = iris_df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})

# Create pairplot
g = sns.pairplot(iris_df, hue='species', diag_kind='kde',
                 plot_kws={'alpha': 0.6, 's': 50, 'edgecolor': 'white', 'linewidth': 0.5},
                 diag_kws={'alpha': 0.7, 'linewidth': 2})
g.fig.suptitle('Iris Dataset: All Pairwise Relationships', y=1.01)
```

The scatter plot matrix shows every possible 2D projection. The diagonal displays the univariate distribution of each feature using KDE. Off-diagonals show bivariate scatter plots. This gives you a complete view of pairwise relationships.

The problem is clear. Scatter plot matrices don't scale. With 10 variables, you have 45 unique pairwise plots, which is manageable but crowded. With 20 variables, you have 190 plots, which becomes overwhelming. And you're still only seeing 2D projections, never the full high-dimensional structure.

This is where dimensionality reduction becomes essential. Instead of looking at every pairwise combination, we project the data intelligently onto just 2 or 3 dimensions.

## Linear Dimensionality Reduction: PCA

Let's talk about Principal Component Analysis (PCA), a linear method that finds directions of maximum variance in your data.

Imagine you have a cloud of points in high-dimensional space. PCA asks a simple question: what direction captures the most variation? This becomes the first principal component (PC1). Then it asks: what direction, perpendicular to the first, captures the most remaining variation? This becomes PC2. And so on.

Mathematically, PCA finds the eigenvectors of the covariance matrix. But conceptually, it's rotating your coordinate system to align with the highest variance directions of your data.

```{python}
#| fig-cap: "PCA finds directions of maximum variance. PC1 captures the most variation, PC2 the next most (perpendicular to PC1)."
#| fig-width: 10
#| fig-height: 6
#| code-fold: true
from sklearn.decomposition import PCA

# Generate correlated 2D data (for visualization)
np.random.seed(123)
mean = [0, 0]
cov = [[3, 2], [2, 2]]
data_2d = np.random.multivariate_normal(mean, cov, 300)

# Fit PCA
pca = PCA(n_components=2)
pca.fit(data_2d)

colors = ["#f2f2f2", sns.color_palette('muted')[0], sns.color_palette('muted')[3]]

# Plot original data with principal components
fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(data_2d[:, 0], data_2d[:, 1], alpha=0.9, s=50, color=colors[0], edgecolors='k', linewidth=0.5)

# Draw principal components as arrows
origin = pca.mean_
for i, (component, variance) in enumerate(zip(pca.components_, pca.explained_variance_)):
    direction = component * np.sqrt(variance) * 3  # Scale for visibility
    ax.arrow(origin[0], origin[1], direction[0], direction[1],
             head_width=0.3, head_length=0.3, fc=colors[i+1], ec=colors[i+1], linewidth=3,
             label=f'PC{i+1} ({variance/pca.explained_variance_.sum()*100:.1f}%)')

ax.set_xlabel('Original X')
ax.set_ylabel('Original Y')
ax.set_title('Principal Components: Directions of Maximum Variance')
ax.legend()
ax.axis('equal')
sns.despine()
```

PC1 (orange arrow) points along the direction of greatest spread. PC2 (green arrow) is perpendicular and captures the remaining variation. The percentage shows how much variance each component explains. If PC1 explains 90 percent of variance, projecting onto just PC1 preserves most of your data's structure.

### Applying PCA to Iris

Let's apply PCA to the 4-dimensional Iris dataset and see how much information we can preserve in just 2 dimensions.

```{python}
#| fig-cap: "PCA projection of Iris dataset to 2D preserves the separation between species"
#| fig-width: 14
#| fig-height: 6
#| code-fold: true
# Prepare data
X = iris.data
y = iris.target

# Standardize (important for PCA!)
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Apply PCA
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Create DataFrame for plotting
pca_df = pd.DataFrame(X_pca, columns=['PC1', 'PC2'])
pca_df['species'] = iris.target_names[y]

# Plot
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Left: PCA projection
for species, color in zip(['setosa', 'versicolor', 'virginica'], sns.color_palette('muted', 3)):
    mask = pca_df['species'] == species
    axes[0].scatter(pca_df.loc[mask, 'PC1'], pca_df.loc[mask, 'PC2'],
                   label=species, alpha=0.7, s=50, color=color, edgecolors='white', linewidth=0.5)
axes[0].set_xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}% variance)')
axes[0].set_ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}% variance)')
axes[0].set_title('PCA Projection of Iris Dataset')
axes[0].legend()
sns.despine(ax=axes[0])

# Right: Variance explained
variances = pca.explained_variance_ratio_
axes[1].bar([1, 2], variances, color=sns.color_palette('muted', 2), alpha=0.7)
axes[1].set_xlabel('Principal Component')
axes[1].set_ylabel('Variance Explained')
axes[1].set_title('Variance Explained by Each Component')
axes[1].set_xticks([1, 2])
axes[1].set_xticklabels(['PC1', 'PC2'])
for i, v in enumerate(variances):
    axes[1].text(i+1, v+0.01, f'{v*100:.1f}%', ha='center', va='bottom', fontsize=11)
sns.despine(ax=axes[1])

plt.tight_layout()
```

PC1 and PC2 together explain over 95 percent of the variance in the 4D dataset. The 2D projection preserves the main structure beautifully. Setosa is well-separated, while versicolor and virginica have some overlap, just as they do in the original high-dimensional space.

A critical reminder: always standardize before PCA. If features have different units or scales, PCA will be dominated by high-variance features. Standardization (zero mean, unit variance) ensures all features contribute fairly.

## Non-Linear Dimensionality Reduction: MDS

Shift your attention from variance to distances. Multidimensional Scaling (MDS) takes a different approach than PCA. Instead of finding directions of maximum variance, it tries to preserve distances between points.

You give MDS a distance matrix showing the distance between every pair of points in high-dimensional space. MDS then finds a low-dimensional configuration where those distances are preserved as well as possible.

Think of it like arranging cities on a map. You know the distance between every pair of cities, but not their coordinates. MDS finds positions that preserve those distances. Mathematically, MDS minimizes stress, the difference between high-dimensional and low-dimensional distances. Classical MDS has a closed-form solution like PCA, but more flexible variants use iterative optimization.

```{python}
#| fig-cap: "MDS vs PCA on Iris dataset. MDS preserves distances better but looks similar to PCA for this dataset."
#| fig-width: 14
#| fig-height: 6
#| code-fold: true
from sklearn.manifold import MDS

# Suppress FutureWarning about n_init in MDS
import warnings
mds = MDS(n_components=2, random_state=42, n_init=1)
X_mds = mds.fit_transform(X_scaled)

# Create DataFrame
mds_df = pd.DataFrame(X_mds, columns=['MDS1', 'MDS2'])
mds_df['species'] = iris.target_names[y]

# Plot both
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# PCA
for species, color in zip(['setosa', 'versicolor', 'virginica'], sns.color_palette('muted', 3)):
    mask = pca_df['species'] == species
    axes[0].scatter(pca_df.loc[mask, 'PC1'], pca_df.loc[mask, 'PC2'],
                   label=species, alpha=0.7, s=50, color=color, edgecolors='white', linewidth=0.5)
axes[0].set_xlabel('PC1')
axes[0].set_ylabel('PC2')
axes[0].set_title('PCA: Maximizes Variance')
axes[0].legend()
sns.despine(ax=axes[0])

# MDS
for species, color in zip(['setosa', 'versicolor', 'virginica'], sns.color_palette('muted', 3)):
    mask = mds_df['species'] == species
    axes[1].scatter(mds_df.loc[mask, 'MDS1'], mds_df.loc[mask, 'MDS2'],
                   label=species, alpha=0.7, s=50, color=color, edgecolors='white', linewidth=0.5)
axes[1].set_xlabel('MDS1')
axes[1].set_ylabel('MDS2')
axes[1].set_title('MDS: Preserves Distances')
axes[1].legend()
sns.despine(ax=axes[1])

plt.tight_layout()
```

For the Iris dataset, PCA and MDS look very similar. This is because Iris data is fairly linear. The relationships between features don't involve complex curves or non-linear structures that would cause MDS to differ significantly from PCA.

## Isomap: Preserving Geodesic Distances

MDS preserves Euclidean distances, which are straight-line distances through space. But for curved manifolds, what matters is the geodesic distance, the distance along the surface.

Isomap (Isometric Mapping) addresses this by approximating geodesic distances using a neighborhood graph. The approach is elegant. First, build a neighborhood graph by connecting each point to its k nearest neighbors. Second, compute shortest paths through this graph. The geodesic distance between points is approximated by the shortest path. Third, apply classical MDS using these geodesic distances instead of Euclidean distances.

Think of it like this. MDS measures distance "as the crow flies," while Isomap measures distance "as you walk along the surface."

```{python}
#| fig-cap: "Isomap uses geodesic distances (along the surface) instead of Euclidean distances (through space), better recovering the S-curve structure"
#| fig-width: 14
#| fig-height: 6
#| code-fold: true
from sklearn.manifold import Isomap
from sklearn.datasets import make_s_curve

# Generate S-curve data (a 2D manifold embedded in 3D)
n_samples = 1000
X_scurve, color = make_s_curve(n_samples, noise=0.1, random_state=42)

# Apply MDS
mds_scurve = MDS(n_components=2, random_state=42, n_init=1)
X_scurve_mds = mds_scurve.fit_transform(X_scurve)

# Apply Isomap
isomap = Isomap(n_components=2, n_neighbors=10)
X_scurve_isomap = isomap.fit_transform(X_scurve)

# Plot MDS vs Isomap
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# MDS
axes[0].scatter(X_scurve_mds[:, 0], X_scurve_mds[:, 1], c=color,
                cmap='viridis', alpha=0.6, s=20)
axes[0].set_xlabel('MDS1')
axes[0].set_ylabel('MDS2')
axes[0].set_title('MDS: Global Euclidean Distances')
sns.despine(ax=axes[0])

# Isomap
axes[1].scatter(X_scurve_isomap[:, 0], X_scurve_isomap[:, 1], c=color,
                cmap='viridis', alpha=0.6, s=20)
axes[1].set_xlabel('Isomap1')
axes[1].set_ylabel('Isomap2')
axes[1].set_title('Isomap: Geodesic Distances')
sns.despine(ax=axes[1])

plt.tight_layout()
```

Isomap successfully "straightens" the S-curve because it respects the manifold structure. By computing distances along the neighborhood graph, it avoids shortcuts across the bend that confused MDS.

The key parameter is n_neighbors. Too few neighbors and the graph becomes disconnected with infinite distances. Too many neighbors and you create shortcuts across the manifold, reverting to MDS-like behavior. Getting it just right (typically 5 to 15) captures the local manifold structure perfectly.

Now we see two extremes emerging. MDS preserves all pairwise distances globally, which works on linear or convex data. Isomap preserves geodesic distances using local neighborhoods, which works on curved manifolds. But what if we only care about local structure? What if global relationships don't matter?

## Modern Non-Linear Methods: t-SNE and UMAP

Let's shift focus to methods that prioritize local structure. Both t-SNE (t-Distributed Stochastic Neighbor Embedding) and UMAP (Uniform Manifold Approximation and Projection) take a middle ground between MDS's global approach and Isomap's geodesic approach. They prioritize local structure while allowing flexibility in global positioning.

The key insight is simple. For visualization, we often care most about which points are neighbors. Whether distant clusters are placed left versus right, or how far apart they are, matters less than preserving local neighborhood relationships within and between clusters.

### How t-SNE works

t-SNE converts distances into similarity probabilities and preserves these local relationships. In high dimensions, we define probability $p_{ij}$ that point $i$ picks point $j$ as a neighbor, based on a Gaussian distance. In low dimensions, we define similar probability $q_{ij}$ using a t-distribution with heavy tails. Then we optimize by moving points in 2D to make $q_{ij}$ match $p_{ij}$, minimizing KL divergence.

The t-distribution's heavy tails are clever. They let well-separated clusters spread out in 2D without overlapping, while keeping local neighborhoods tight.

```{python}
#| fig-cap: "Comparing global, geodesic, and local approaches on the S-curve"
#| fig-width: 15
#| fig-height: 5
#| code-fold: true
from sklearn.manifold import TSNE

# Apply t-SNE
tsne = TSNE(n_components=2, random_state=42, perplexity=30)
X_scurve_tsne = tsne.fit_transform(X_scurve)

# Plot all three methods
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# MDS - Global Euclidean distances
axes[0].scatter(X_scurve_mds[:, 0], X_scurve_mds[:, 1], c=color,
                cmap='viridis', alpha=0.6, s=20)
axes[0].set_xlabel('MDS1')
axes[0].set_ylabel('MDS2')
axes[0].set_title('MDS: Global Distances')
sns.despine(ax=axes[0])

# Isomap - Geodesic distances
axes[1].scatter(X_scurve_isomap[:, 0], X_scurve_isomap[:, 1], c=color,
                cmap='viridis', alpha=0.6, s=20)
axes[1].set_xlabel('Isomap1')
axes[1].set_ylabel('Isomap2')
axes[1].set_title('Isomap: Geodesic Distances')
sns.despine(ax=axes[1])

# t-SNE - Local neighborhoods
axes[2].scatter(X_scurve_tsne[:, 0], X_scurve_tsne[:, 1], c=color,
                cmap='viridis', alpha=0.6, s=20)
axes[2].set_xlabel('t-SNE1')
axes[2].set_ylabel('t-SNE2')
axes[2].set_title('t-SNE: Local Structure')
sns.despine(ax=axes[2])

plt.tight_layout()
```

All three methods successfully straighten the S-curve, but through different philosophies. MDS compromises between all distances. Isomap follows the manifold globally. t-SNE focuses on preserving neighborhoods. Each makes different trade-offs between local and global structure.

The key parameter in t-SNE is perplexity, which typically ranges from 30 to 50. Perplexity controls the effective neighborhood size. Too low perplexity fragments clusters. Too high perplexity loses local detail. Finding the right balance is important.

### What t-SNE preserves (and what it doesn't)

t-SNE is powerful but has important limitations. It preserves local structure, keeping points that are neighbors in high dimensions as neighbors in 2D. It preserves clusters, keeping well-separated groups separated. It preserves relative relationships within neighborhoods. If A is closer to B than to C locally, this is preserved.

What t-SNE does NOT preserve: actual distances between points are not meaningful. The relative position of distant clusters is arbitrary. Large clusters may appear smaller, and vice versa. Tight clusters may be spread out, and sparse regions may appear dense.

You cannot conclude from a t-SNE plot that "cluster A is twice as far from B as from C." Distances are not preserved. You cannot conclude that "cluster A is twice the size of B." Sizes are not preserved. You cannot conclude that "the data has exactly 5 clusters." Apparent clusters may be visualization artifacts.

You can conclude that "these points form a distinct group separate from others." You can conclude that "these points are more similar to each other than to distant points." You can conclude that "the data has local structure and is not uniformly random."

### Applying t-SNE to real data

Let's apply t-SNE to a more realistic high-dimensional dataset: the digits dataset, which has 64 dimensions (8 by 8 pixel images).

```{python}
#| fig-cap: "t-SNE visualization of handwritten digits (64 dimensions to 2D). Each color represents a digit class."
#| fig-width: 12
#| fig-height: 10
#| code-fold: true
from sklearn.datasets import load_digits

# Load digits dataset (8x8 images, 64 dimensions)
digits = load_digits()
X_digits = digits.data
y_digits = digits.target

# Take a subset for speed (t-SNE is slow on large datasets)
np.random.seed(42)
indices = np.random.choice(len(X_digits), size=1000, replace=False)
X_subset = X_digits[indices]
y_subset = y_digits[indices]

# Apply t-SNE
tsne_digits = TSNE(n_components=2, random_state=42, perplexity=40)
X_digits_tsne = tsne_digits.fit_transform(X_subset)

# Plot
fig, ax = plt.subplots(figsize=(12, 10))
scatter = ax.scatter(X_digits_tsne[:, 0], X_digits_tsne[:, 1],
                     c=y_subset, cmap='tab10', alpha=0.7, s=30)
ax.set_xlabel('t-SNE1')
ax.set_ylabel('t-SNE2')
ax.set_title('t-SNE Visualization of Handwritten Digits (64D to 2D)')
cbar = plt.colorbar(scatter, ax=ax, ticks=range(10))
cbar.set_label('Digit Class')
sns.despine()
```

The t-SNE projection beautifully separates most digit classes. Digits that look similar (3, 5, and 8) cluster near each other. Visually distinct digits (0 and 1) are well separated.

This demonstrates t-SNE's power. From 64 dimensions with no explicit information about what makes digits similar, t-SNE discovers the perceptual structure of handwritten digits. It's a remarkable achievement in unsupervised learning.

An important note: t-SNE is stochastic. Different runs produce different layouts, though cluster structure remains consistent. Always check multiple runs with different random seeds, especially for scientific conclusions.

## UMAP: A Faster Alternative

Uniform Manifold Approximation and Projection (UMAP) is a newer method from 2018 that has become popular as an alternative to t-SNE. Like t-SNE, UMAP preserves local structure. But it's based on different mathematical foundations in manifold learning and topological data analysis.

UMAP has several advantages over t-SNE. It's faster, often 10 to 100 times faster on large datasets. It scales better, working well on datasets with millions of points. It preserves more global structure than t-SNE. It's also theoretically grounded in Riemannian geometry and fuzzy topology.

The trade-offs are worth noting. UMAP is less battle-tested since it's newer. It has more hyperparameters to tune, though defaults work well. It often produces similar-looking results to t-SNE, so the choice often comes down to speed.

```{python}
#| fig-cap: "UMAP vs t-SNE on digits dataset. UMAP often preserves more global structure while being much faster."
#| fig-width: 14
#| fig-height: 6
#| code-fold: true
import umap

# Apply UMAP
umap_model = umap.UMAP(n_components=2, random_state=42, n_neighbors=30)
X_digits_umap = umap_model.fit_transform(X_subset)

# Plot comparison
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# t-SNE
scatter = axes[0].scatter(X_digits_tsne[:, 0], X_digits_tsne[:, 1],
                          c=y_subset, cmap='tab10', alpha=0.7, s=30)
axes[0].set_xlabel('t-SNE1')
axes[0].set_ylabel('t-SNE2')
axes[0].set_title('t-SNE')
sns.despine(ax=axes[0])

# UMAP
scatter = axes[1].scatter(X_digits_umap[:, 0], X_digits_umap[:, 1],
                          c=y_subset, cmap='tab10', alpha=0.7, s=30)
axes[1].set_xlabel('UMAP1')
axes[1].set_ylabel('UMAP2')
axes[1].set_title('UMAP')
cbar = plt.colorbar(scatter, ax=axes[1], ticks=range(10))
cbar.set_label('Digit Class')
sns.despine(ax=axes[1])

plt.tight_layout()
```

Both methods reveal similar cluster structure. But UMAP tends to space clusters more evenly and preserve more global topology. Notice how UMAP places similar digits (3, 5, 8) in a connected region, suggesting they share underlying structure.

When should you use UMAP? Use it for very large datasets (over 10,000 points) where t-SNE becomes slow. Use it when you want to preserve more global structure. Use it when you're doing exploratory analysis and want fast iteration. UMAP also supports projecting new data onto an existing embedding, which t-SNE doesn't easily support.

When should you stick with t-SNE? Use it when you need the most established method with extensive literature. Use it for moderate-sized datasets where speed isn't critical. Use it when you're replicating published work that used t-SNE.

## The Bigger Picture: Choosing the Right Method

Let's step back and see the full landscape. Dimensionality reduction is not a one-size-fits-all solution. Different methods make different trade-offs:

| Method | Preserves | Speed | Scalability | When to use |
|--------|-----------|-------|-------------|-------------|
| **Scatter plot matrix** | Everything (2D projections) | Fast | 3-10 dimensions | Exploring moderate-dimensional data |
| **PCA** | Global variance | Very fast | Excellent (1000s of dims) | Linear structure, interpretability needed |
| **MDS** | All distances | Slow | Poor (100s of points) | Distance preservation critical |
| **t-SNE** | Local structure | Slow | Moderate (10,000s of points) | Revealing clusters, local relationships |
| **UMAP** | Local plus some global | Fast | Excellent (millions of points) | Large datasets, faster alternative to t-SNE |

A practical workflow begins with PCA. Always run PCA first. It's fast, interpretable, and if it works well, you're done. Check how much variance the first 2 or 3 components explain.

Next, check pairwise plots if feasible. If you have fewer than 10 dimensions, look at scatter plot matrices to understand pairwise relationships.

Try t-SNE or UMAP if PCA doesn't reveal clear structure. Run them if the first 2 PCs explain less than 50 percent variance. Try them if you suspect non-linear relationships. Try them if you want to find clusters.

Validate your findings with multiple approaches. Don't trust a single visualization. Try different random seeds for t-SNE and UMAP. Try different hyperparameters like perplexity and number of neighbors. Try different methods and see if t-SNE and PCA agree. Run statistical tests on apparent clusters.

::: {.callout-tip title="Try it yourself"}
Take a dataset you're familiar with and apply all four methods: PCA, MDS, t-SNE, and UMAP. Compare the results. What structure does each method reveal? What structure does each method hide? Which visualization best matches your intuition about the data?
:::

Dimensionality reduction can create apparent patterns that don't exist in the original data. Spurious clusters appear when t-SNE splits continuous data into false groups. Missing relationships occur when two clusters might be connected in high dimensions but appear separated in 2D. Misleading distances happen when distance and size in t-SNE and UMAP are not meaningful.

Always validate important findings with statistical tests or domain knowledge. A beautiful t-SNE plot is a starting point for investigation, not a final conclusion.

Visualizing high-dimensional data is as much art as science. The goal is not to find "the true projection." There is no single true way to flatten high-dimensional space onto a page. The goal is to reveal structure that helps you understand your data and ask better questions.

As data scientist Jake VanderPlas wrote, "Dimensionality reduction is a form of lossy compression. The question is not whether you lose information (you always do) but whether you lose the information you care about."
