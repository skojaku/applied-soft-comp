{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "jupytext:\n",
        "  formats: md:myst\n",
        "  text_representation:\n",
        "    extension: .md\n",
        "    format_name: myst\n",
        "kernelspec:\n",
        "  display_name: Python 3\n",
        "  language: python\n",
        "  name: python3\n",
        "---\n",
        "\n",
        "# LeNet and LeNet-5: Pioneering CNN Architectures\n",
        "\n",
        "How can a neural network learn to recognize complex visual patterns—like handwritten digits—without relying on hand-crafted features?\n",
        "\n",
        "In the late 1980s and early 1990s, hand-engineered feature extraction dominated machine learning approaches to computer vision. This process was laborious and often inflexible. **LeNet** {footcite}`lecun1989backpropagation` offered a radical alternative by showing that a network could learn these features directly from raw pixel data.\n",
        "\n",
        "The most influential incarnation, **LeNet-5** {footcite}`lecun1998gradient`, demonstrated impressive performance on handwritten digit recognition, finding real-world application in automated check reading and postal code processing. Although modern networks have grown significantly in depth and complexity, the core ideas from LeNet remain fundamental to today’s convolutional neural networks (CNNs).\n",
        "\n",
        "```{note}\n",
        "LeNet popularized the key innovations of convolution, pooling, and end-to-end learning—approaches that form the foundation for modern deep learning in computer vision.\n",
        "```\n",
        "\n",
        "## Learning Objectives\n",
        "- Understand the historical context and motivation behind the LeNet family of architectures.\n",
        "- Explore the architectural components (convolution, pooling, and sparse connectivity) that enabled effective pattern learning.\n",
        "- Implement a simplified version of LeNet-1 in PyTorch to gain hands-on experience.\n",
        "- Reflect on how LeNet’s innovations paved the way for more advanced CNNs.\n",
        "\n",
        "## Conceptual Foundation\n",
        "\n",
        "Before LeNet, engineers painstakingly crafted feature extractors for each vision task: edges, corners, specific shapes, etc. This approach was time-consuming, difficult to generalize, and prone to missing subtle features crucial for classification.\n",
        "\n",
        "LeNet challenged this paradigm by **automating feature extraction**. It did this through layers that systematically learn local patterns (via convolution) and gradually build more global representations (via subsampling/pooling). This hierarchical approach mimics aspects of human visual perception, where lower-level patterns combine into higher-level objects.\n",
        "\n",
        "```{note}\n",
        "**Historical Context**:\n",
        "Yann LeCun’s work on applying backpropagation to convolutional architectures in the 1980s was met with skepticism. But the success of LeNet on real-world tasks (e.g., check reading at banks) helped spark wider interest in neural network approaches to image recognition.\n",
        "```\n",
        "\n",
        "## Architecture\n",
        "\n",
        "LeNet actually refers to several iterative designs. In what follows, we examine two key versions: **LeNet-1** (the earliest demonstration) and **LeNet-5** (the widely known and more powerful network).\n",
        "\n",
        "### LeNet-1\n",
        "\n",
        "```{figure} https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ge5OLutAT9_3fxt_sKTBGA.png\n",
        "---\n",
        "width: 100%\n",
        "name: lenet\n",
        "---\n",
        "LeNet-1 architecture.\n",
        "```\n",
        "\n",
        "1. **Convolution (C1)**: Takes a $28\\times28$ (originally $32\\times32$ in some demos) grayscale image and applies 4 filters of size $5\\times5$. This step captures basic patterns like edges and corners.\n",
        "\n",
        "2. **Pooling (S2)**: Applies average pooling (subsampling) with a $2\\times2$ window, reducing the spatial dimensions from $24\\times24$ to $12\\times12$. This coarse-grains the features, allowing the network to focus on more abstract patterns.\n",
        "\n",
        "3. **Second Convolution (C3)**: Produces more feature maps (12 feature maps). By stacking multiple convolutions, the network builds increasingly complex features.\n",
        "\n",
        "4. **Second Pooling (S4)**: Another average pooling layer further reduces spatial dimensions to $4\\times4$.\n",
        "\n",
        "5. **Fully Connected Layers**: The network flattens these features and passes them through a fully connected layer to produce a 10-class output (digits 0–9).\n",
        "\n",
        "```{note}\n",
        "This hierarchical processing—convolution followed by subsampling—mimics the structure of the visual cortex, where neurons respond to progressively more complex stimuli in each stage.\n",
        "```\n",
        "\n",
        "### LeNet-5\n",
        "\n",
        "```{figure} https://www.datasciencecentral.com/wp-content/uploads/2021/10/1lvvWF48t7cyRWqct13eU0w.jpeg\n",
        "---\n",
        "width: 100%\n",
        "name: lenet-5\n",
        "---\n",
        "LeNet-5 architecture.\n",
        "```\n",
        "\n",
        "LeNet-5 builds on LeNet-1 but **scales up the number of learnable parameters** and introduces a few architectural refinements:\n",
        "\n",
        "1. **Input Normalization**: Inputs (grayscale images) are normalized to a range of roughly $[-0.1, 1.175]$. This centering speeds up training and stabilizes the gradients.\n",
        "\n",
        "2. **Convolution + Subsampling Pairs**: Similar to LeNet-1, but with more feature maps and a **mean pooling** mechanism. Each pooling step is followed by a **non-linear activation** (often the sigmoid, though other activations can be used).\n",
        "\n",
        "3. **Sparse Connectivity (C3)**: Not every feature map in the previous layer connects to every feature map in the next layer. This selective approach reduces parameters and encourages **diverse features** rather than overly correlated ones.\n",
        "\n",
        "4. **Transition to 1D**: Instead of simply flattening, LeNet-5 includes a convolutional layer (C5) that bridges 2D feature maps to a fully connected layer, preserving more spatial structure.\n",
        "\n",
        "5. **Final RBF Layer** (in the original paper): An additional radial-basis-function layer was sometimes used to enhance feature representation. Modern implementations often simplify this to a linear or fully connected layer.\n",
        "\n",
        "```{note}\n",
        "**Parameter Efficiency**: One reason LeNet-5 performed well on the limited hardware of the 1990s is its careful use of sparse connections to reduce the number of parameters.\n",
        "```\n",
        "\n",
        "## Implementation\n",
        "\n",
        "In this section, we will implement a simplified **LeNet-1** in PyTorch. While LeNet-1 was traditionally trained with batch gradient descent and certain custom optimizations, our example will use **modern tooling**—such as **PyTorch Lightning** and the **Adam** optimizer—to streamline the training process.\n",
        "\n",
        "### Dataset: MNIST\n",
        "\n",
        "We will train our model on the MNIST dataset, a classic benchmark of $28\\times28$ handwritten digits. MNIST is split into 60,000 training and 10,000 test images.\n",
        "\n",
        "```{figure} https://production-media.paperswithcode.com/datasets/MNIST-0000000001-2e09631a_09liOmx.jpg\n",
        "---\n",
        "width: 100%\n",
        "name: mnist\n",
        "---\n",
        "MNIST dataset (digits 0–9 in handwritten form).\n",
        "```\n",
        "\n",
        "```{tip}\n",
        "**Why MNIST?**\n",
        "- Small image size (28x28) → Perfect for simple convolutional nets.\n",
        "- 10 distinct classes → Easy to measure classification accuracy.\n",
        "- Widely used → Many existing examples to compare against.\n",
        "```\n",
        "\n",
        "### Data Preparation with PyTorch Lightning\n",
        "\n",
        "```{code-cell} ipython3\n",
        "import torch\n",
        "import torch.nn as nn\n",
        "import torch.nn.functional as F\n",
        "import pytorch_lightning as pl\n",
        "from torch.utils.data import DataLoader, random_split\n",
        "from torchvision import datasets, transforms\n",
        "from torchmetrics import Accuracy\n",
        "\n",
        "class MNISTDataModule(pl.LightningDataModule):\n",
        "    \"\"\"\n",
        "    PyTorch Lightning data module for MNIST dataset\n",
        "    \"\"\"\n",
        "    def __init__(self, data_dir: str = './data', batch_size: int = 32):\n",
        "        super().__init__()\n",
        "        self.data_dir = data_dir\n",
        "        self.batch_size = batch_size\n",
        "\n",
        "        # Define transforms\n",
        "        self.transform = transforms.Compose([\n",
        "            transforms.ToTensor(),           # Convert PIL image to torch.Tensor\n",
        "            transforms.Normalize((0,), (1,)) # Normalize to mean=0, std=1\n",
        "        ])\n",
        "\n",
        "    def prepare_data(self):\n",
        "        \"\"\"Download data if needed.\"\"\"\n",
        "        datasets.MNIST(self.data_dir, train=True, download=True)\n",
        "        datasets.MNIST(self.data_dir, train=False, download=True)\n",
        "\n",
        "    def setup(self, stage=None):\n",
        "        \"\"\"Setup train, val, and test datasets.\"\"\"\n",
        "        if stage == 'fit' or stage is None:\n",
        "            mnist_full = datasets.MNIST(self.data_dir, train=True, transform=self.transform)\n",
        "            self.mnist_train, self.mnist_val = random_split(\n",
        "                mnist_full, [55000, 5000], generator=torch.Generator().manual_seed(42)\n",
        "            )\n",
        "\n",
        "        if stage == 'test' or stage is None:\n",
        "            self.mnist_test = datasets.MNIST(self.data_dir, train=False, transform=self.transform)\n",
        "\n",
        "    def train_dataloader(self):\n",
        "        return DataLoader(self.mnist_train, batch_size=self.batch_size, shuffle=True, num_workers=1)\n",
        "\n",
        "    def val_dataloader(self):\n",
        "        return DataLoader(self.mnist_val, batch_size=self.batch_size, num_workers=1)\n",
        "\n",
        "    def test_dataloader(self):\n",
        "        return DataLoader(self.mnist_test, batch_size=self.batch_size, num_workers=1)\n",
        "```\n",
        "\n",
        "```{note}\n",
        "**PyTorch Lightning DataModule**:\n",
        "- Ensures consistent data splits for training, validation, and testing.\n",
        "- Handles shuffling, batching, and transformation pipelines.\n",
        "- Makes code cleaner and easier to maintain.\n",
        "```\n",
        "\n",
        "### Model Definition\n",
        "\n",
        "```{code-cell} ipython3\n",
        "class LeNet1(pl.LightningModule):\n",
        "    \"\"\"\n",
        "    PyTorch Lightning implementation of LeNet-1\n",
        "    \"\"\"\n",
        "\n",
        "    def __init__(self, learning_rate=1e-3):\n",
        "        super(LeNet1, self).__init__()\n",
        "        self.save_hyperparameters()\n",
        "\n",
        "        # Metrics\n",
        "        self.train_accuracy = Accuracy(task=\"multiclass\", num_classes=10)\n",
        "        self.val_accuracy = Accuracy(task=\"multiclass\", num_classes=10)\n",
        "        self.test_accuracy = Accuracy(task=\"multiclass\", num_classes=10)\n",
        "\n",
        "        # First convolutional layer (Input: 1x28x28 -> Output: 4x24x24)\n",
        "        self.conv1 = nn.Conv2d(in_channels=1, out_channels=4, kernel_size=5, stride=1)\n",
        "\n",
        "        # Average pooling layer (4x24x24 -> 4x12x12)\n",
        "        self.pool = nn.AvgPool2d(kernel_size=2, stride=2)\n",
        "\n",
        "        # Second convolutional layer (4x12x12 -> 12x8x8)\n",
        "        self.conv2 = nn.Conv2d(in_channels=4, out_channels=12, kernel_size=5, stride=1)\n",
        "\n",
        "        # Fully connected layer (12*4*4=192 -> 10)\n",
        "        self.fc = nn.Linear(12 * 4 * 4, 10)\n",
        "\n",
        "        # Initialize weights\n",
        "        self._init_weights()\n",
        "\n",
        "        # Track losses over time (for visualization)\n",
        "        self.val_losses = []\n",
        "        self.train_losses = []\n",
        "\n",
        "    def _init_weights(self):\n",
        "        \"\"\"Initialize weights with Xavier initialization.\"\"\"\n",
        "        for m in self.modules():\n",
        "            if isinstance(m, nn.Conv2d) or isinstance(m, nn.Linear):\n",
        "                nn.init.xavier_uniform_(m.weight)\n",
        "                nn.init.zeros_(m.bias)\n",
        "\n",
        "    def forward(self, x):\n",
        "        # First conv block\n",
        "        x = self.conv1(x)\n",
        "        x = torch.tanh(x)  # Using tanh for nonlinearity\n",
        "        x = self.pool(x)\n",
        "\n",
        "        # Second conv block\n",
        "        x = self.conv2(x)\n",
        "        x = torch.tanh(x)\n",
        "        x = self.pool(x)\n",
        "\n",
        "        # Flatten and fully connected\n",
        "        x = x.view(-1, 12 * 4 * 4)\n",
        "        x = self.fc(x)\n",
        "        return x\n",
        "\n",
        "    def configure_optimizers(self):\n",
        "        \"\"\"Define optimizer and LR scheduler.\"\"\"\n",
        "        optimizer = torch.optim.Adam(self.parameters(), lr=self.hparams.learning_rate)\n",
        "        scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(\n",
        "            optimizer, mode=\"min\", factor=0.1, patience=10, verbose=True\n",
        "        )\n",
        "        return {\n",
        "            \"optimizer\": optimizer,\n",
        "            \"lr_scheduler\": {\"scheduler\": scheduler, \"monitor\": \"val_loss\"}\n",
        "        }\n",
        "\n",
        "    def training_step(self, batch, batch_idx):\n",
        "        \"\"\"Train on a single batch.\"\"\"\n",
        "        x, y = batch\n",
        "        logits = self(x)\n",
        "        loss = F.cross_entropy(logits, y)\n",
        "\n",
        "        acc = self.train_accuracy(logits, y)\n",
        "        self.log(\"train_loss\", loss, prog_bar=True)\n",
        "        self.log(\"train_acc\", acc, prog_bar=True)\n",
        "\n",
        "        self.train_losses.append({\"loss\": loss.item(), \"acc\": acc.item()})\n",
        "        return loss\n",
        "\n",
        "    def validation_step(self, batch, batch_idx):\n",
        "        \"\"\"Validate on a single batch.\"\"\"\n",
        "        x, y = batch\n",
        "        logits = self(x)\n",
        "        loss = F.cross_entropy(logits, y)\n",
        "\n",
        "        acc = self.val_accuracy(logits, y)\n",
        "        self.log(\"val_loss\", loss, prog_bar=True)\n",
        "        self.log(\"val_acc\", acc, prog_bar=True)\n",
        "\n",
        "        self.val_losses.append({\"loss\": loss.item(), \"acc\": acc.item()})\n",
        "\n",
        "    def test_step(self, batch, batch_idx):\n",
        "        \"\"\"Test on a single batch.\"\"\"\n",
        "        x, y = batch\n",
        "        logits = self(x)\n",
        "        loss = F.cross_entropy(logits, y)\n",
        "\n",
        "        acc = self.test_accuracy(logits, y)\n",
        "        self.log(\"test_loss\", loss, prog_bar=True)\n",
        "        self.log(\"test_acc\", acc, prog_bar=True)\n",
        "```\n",
        "\n",
        "### Training the Model\n",
        "\n",
        "```{code-cell} ipython3\n",
        "# Initialize model and data\n",
        "model = LeNet1(learning_rate=1e-3)\n",
        "data_module = MNISTDataModule(batch_size=256)\n",
        "\n",
        "# Initialize trainer\n",
        "trainer = pl.Trainer(\n",
        "    max_epochs=2,\n",
        "    accelerator=\"auto\",  # Use GPU if available\n",
        "    devices=1,\n",
        ")\n",
        "\n",
        "# Train\n",
        "trainer.fit(model, data_module)\n",
        "```\n",
        "\n",
        "```{tip}\n",
        "**Check GPU usage**:\n",
        "- If you have a GPU available, `accelerator=\"auto\"` automatically leverages it.\n",
        "- Otherwise, it trains on CPU, which is slower but will still work for a small model like LeNet-1.\n",
        "```\n",
        "\n",
        "### Monitoring Validation Loss\n",
        "\n",
        "```{code-cell} ipython3\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "import pandas as pd\n",
        "\n",
        "df_val = pd.DataFrame(model.val_losses)\n",
        "df_val[\"Iteration\"] = df_val.index\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 6))\n",
        "sns.lineplot(x=\"Iteration\", y=\"loss\", data=df_val, label=\"Validation Loss\", ax=ax)\n",
        "ax.set_title(\"Validation Loss Over Time\")\n",
        "ax.set_xlabel(\"Iteration\")\n",
        "ax.set_ylabel(\"Loss\")\n",
        "plt.show()\n",
        "```\n",
        "\n",
        "### Testing\n",
        "\n",
        "```{code-cell} ipython3\n",
        "trainer.test(model, data_module)\n",
        "```\n",
        "\n",
        "Observe the final test loss and test accuracy. Even this simple LeNet-1 inspired model often achieves high accuracy on MNIST—demonstrating how effective early CNN architectures can be.\n",
        "\n",
        "## Reflection and Exercises\n",
        "\n",
        "1. **Experiment**:\n",
        "   - Vary the learning rate and batch size to see how training dynamics change.\n",
        "   - Replace `tanh` activation with `ReLU` or `Sigmoid` and compare performance.\n",
        "\n",
        "2. **Visual Inspection**:\n",
        "   - Hand-draw a digit (e.g., using a graphics tool) and see whether the model correctly classifies it. If it fails, hypothesize why (differences in stroke thickness, image alignment, etc.).\n",
        "\n",
        "3. **Architectural Tweaks**:\n",
        "   - Try adding an additional convolutional layer or using different pooling strategies (like max pooling) to see if you can improve accuracy.\n",
        "\n",
        "\n",
        "```{note}\n",
        "**Real-world Application**:\n",
        "LeNet’s core ideas are still used in modern banking systems to read checks automatically. Its principle of learning features from raw data underpins almost all modern deep-learning-based image classification systems.\n",
        "```\n",
        "\n",
        "## Further Reading\n",
        "\n",
        "- [**Writing LeNet5 from Scratch in PyTorch (DigitalOcean)**](https://www.digitalocean.com/community/tutorials/writing-lenet5-from-scratch-in-python)\n",
        "- [**PyTorch LeNet Implementation Video**](https://m.youtube.com/watch?v=fcOW-Zyb5Bo&pp=ygUGI2xlbmV0)\n",
        "- [**Original LeCun Paper**](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)\n",
        "\n",
        "```{footbibliography}\n",
        ":style: unsrt\n",
        ":filter: docname in docnames\n",
        "```\n",
        "\n",
        "## Summary\n",
        "\n",
        "In summary, **LeNet** {footcite}`lecun1989backpropagation` and **LeNet-5** {footcite}`lecun1998gradient` formed the basis for convolutional networks that learn directly from data. By incorporating convolution, subsampling, sparse connectivity, and end-to-end training, LeNet demonstrated how networks can autonomously discover robust representations—laying the groundwork for today’s deep learning revolution."
      ],
      "id": "55b31350"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "applsoftcomp",
      "language": "python",
      "display_name": "Python (applsoftcomp)",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/applsoftcomp"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}