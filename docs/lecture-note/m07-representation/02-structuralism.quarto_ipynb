{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Part 2: Meaning as Difference\"\n",
        "jupyter: python3\n",
        "execute:\n",
        "    enabled: true\n",
        "    cache: true\n",
        "---\n",
        "\n",
        "::: {.callout-note title=\"What you'll learn in this section\"}\n",
        "Meaning doesn't live inside words like water in a container. It emerges from networks of contrast and opposition. We'll explore how Saussure, Buddhist logic, Jakobson, and Lévi-Strauss converged on this structuralist insight, and why it matters for machine learning.\n",
        ":::\n",
        "\n",
        "## The Arbitrary Nature of Signs\n",
        "\n",
        "Let's start with a simple observation that changes everything. What makes the English word \"dog\" mean what it means? You might answer that it refers to a four-legged canine animal. But why those particular sounds? Why not \"chien\" (French), \"perro\" (Spanish), or \"犬\" (Japanese)? The connection between the sound pattern and the concept is arbitrary.\n",
        "\n",
        "Ferdinand de Saussure, the founder of modern linguistics, called this the arbitrariness of the sign. A sign has two parts: the signifier (the sound or written form) and the signified (the concept). The relationship between them is not natural or inevitable. It's a social convention.\n",
        "\n",
        "::: {.column-margin}\n",
        "Saussure's *Course in General Linguistics* (1916) revolutionized language study by treating it as a system of relationships rather than a collection of labels.\n",
        ":::\n",
        "\n",
        "But Saussure went further. He argued that the signified (the concept itself) is also arbitrary. We think \"dog\" refers to a pre-existing natural category, but nature doesn't draw boundaries between dogs, wolves, and foxes. We do. Different languages slice the animal kingdom differently. Some languages have multiple words for what English calls \"rice\" (depending on whether it's cooked or raw). English distinguishes \"river\" from \"stream\" where other languages use one word. The concepts themselves are products of how a language chooses to divide conceptual space.\n",
        "\n",
        "This leads to a radical conclusion. The meaning of \"dog\" isn't determined by what dogs are. It's determined by what dogs are not. \"Dog\" means \"dog\" because it occupies a specific position in a network of differences: not \"cat\", not \"wolf\", not \"fox\", not \"log\", not \"fog\"."
      ],
      "id": "119bf5ad"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: The meaning of 'dog' emerges from its position in a network of contrasts, not from an intrinsic essence.\n",
        "#| label: fig-saussure-system\n",
        "#| code-fold: true\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import networkx as nx\n",
        "import numpy as np\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 8))\n",
        "\n",
        "# Create a network showing semantic relationships\n",
        "G = nx.Graph()\n",
        "\n",
        "# Add nodes\n",
        "center_word = \"DOG\"\n",
        "related = [\"cat\", \"wolf\", \"fox\", \"puppy\", \"pet\"]\n",
        "contrasts = [\"log\", \"fog\", \"cog\", \"dig\"]\n",
        "\n",
        "G.add_node(center_word)\n",
        "for word in related + contrasts:\n",
        "    G.add_node(word)\n",
        "\n",
        "# Add edges for related terms\n",
        "for word in related:\n",
        "    G.add_edge(center_word, word)\n",
        "\n",
        "# Position nodes\n",
        "pos = {center_word: (0, 0)}\n",
        "\n",
        "# Related words in a circle around center\n",
        "angle_step = 2 * np.pi / len(related)\n",
        "for i, word in enumerate(related):\n",
        "    angle = i * angle_step\n",
        "    pos[word] = (1.5 * np.cos(angle), 1.5 * np.sin(angle))\n",
        "\n",
        "# Contrast words further out\n",
        "angle_step = 2 * np.pi / len(contrasts)\n",
        "for i, word in enumerate(contrasts):\n",
        "    angle = i * angle_step + np.pi/4\n",
        "    pos[word] = (2.5 * np.cos(angle), 2.5 * np.sin(angle))\n",
        "\n",
        "# Draw the network\n",
        "# Center node\n",
        "nx.draw_networkx_nodes(G, pos, nodelist=[center_word],\n",
        "                       node_color='#e74c3c', node_size=3000,\n",
        "                       alpha=0.9, ax=ax)\n",
        "\n",
        "# Related nodes\n",
        "nx.draw_networkx_nodes(G, pos, nodelist=related,\n",
        "                       node_color='#3498db', node_size=2000,\n",
        "                       alpha=0.7, ax=ax)\n",
        "\n",
        "# Contrast nodes\n",
        "nx.draw_networkx_nodes(G, pos, nodelist=contrasts,\n",
        "                       node_color='#95a5a6', node_size=1500,\n",
        "                       alpha=0.5, ax=ax)\n",
        "\n",
        "# Edges\n",
        "nx.draw_networkx_edges(G, pos, width=2, alpha=0.3, ax=ax)\n",
        "\n",
        "# Labels\n",
        "nx.draw_networkx_labels(G, pos,\n",
        "                        {center_word: center_word},\n",
        "                        font_size=16, font_weight='bold',\n",
        "                        font_color='white', ax=ax)\n",
        "\n",
        "label_pos = {k: (v[0], v[1]) for k, v in pos.items() if k != center_word}\n",
        "nx.draw_networkx_labels(G, label_pos,\n",
        "                        {k: k for k in related + contrasts},\n",
        "                        font_size=11, font_weight='bold', ax=ax)\n",
        "\n",
        "# Add annotations\n",
        "ax.text(0, -3.3, '\"Dog\" is defined by what it is NOT', fontsize=13,\n",
        "        ha='center', style='italic', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n",
        "\n",
        "ax.set_xlim(-3.5, 3.5)\n",
        "ax.set_ylim(-3.5, 3.5)\n",
        "ax.axis('off')\n",
        "ax.set_title('Saussurean Semiotics: Meaning Through Difference',\n",
        "             fontsize=16, fontweight='bold', pad=20)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-saussure-system",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Apoha: Buddhist Logic of Negation\n",
        "\n",
        "This idea that concepts are defined through negation has deep roots. Buddhist philosophers in ancient India developed a theory called Apoha (literally \"exclusion\") around the 5th century CE. They argued that we cannot understand what a thing is, only what it is not.\n",
        "\n",
        "When you see a horse, you don't directly grasp \"horseness\". Instead, you implicitly exclude everything that is not-horse: not-cow, not-stone, not-water, not-tree. The concept of \"horse\" is nothing more than the region of conceptual space that remains after all these exclusions. It's a purely negative definition.\n",
        "\n",
        "::: {.column-margin}\n",
        "Dignāga and Dharmakīrti, the primary developers of Apoha theory, influenced both Indian and Tibetan Buddhist philosophy. Their ideas parallel Saussure's insights developed independently 1400 years later.\n",
        ":::\n",
        "\n",
        "Why does this matter? Because it reveals that categories are not containers holding essences. They're regions in a space of possibilities, carved out by contrast. This shifts the entire frame. You don't need to know what something is. You only need to know what it is not. The meaning is in the boundaries, not the interior.\n",
        "\n",
        "## Jakobson's Binary Oppositions\n",
        "\n",
        "Roman Jakobson, a 20th-century linguist, took the structuralist insight and formalized it. He studied phonemes—the basic sound units of language—and showed they could be decomposed into binary features.\n",
        "\n",
        "Consider the difference between \"p\" and \"b\". They're produced almost identically: both are bilabial stops (you close your lips and release air). The only difference is voicing. Your vocal cords vibrate for \"b\" but not for \"p\". We can represent this as:\n",
        "\n",
        "- \"p\": [+bilabial, +stop, -voiced]\n",
        "- \"b\": [+bilabial, +stop, +voiced]\n",
        "\n",
        "Jakobson showed that all phonemes in all languages could be analyzed as bundles of such binary oppositions: voiced/voiceless, nasal/oral, fricative/stop, and so on. A phoneme isn't a sound. It's a position in a multidimensional space of contrasts."
      ],
      "id": "8345708b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: Phonemes as vectors in a space of binary features. Position, not essence, determines identity.\n",
        "#| label: fig-jakobson-features\n",
        "#| code-fold: true\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "\n",
        "# Define phonemes with binary features\n",
        "phonemes = {\n",
        "    'p': [1, 1, 0],  # [bilabial, stop, voiced]\n",
        "    'b': [1, 1, 1],\n",
        "    't': [0, 1, 0],  # [dental, stop, voiced]\n",
        "    'd': [0, 1, 1],\n",
        "    'k': [0, 0, 0],  # [velar, stop, voiced]\n",
        "    'g': [0, 0, 1]\n",
        "}\n",
        "\n",
        "# Create DataFrame\n",
        "df = pd.DataFrame.from_dict(phonemes, orient='index',\n",
        "                            columns=['Bilabial', 'Stop', 'Voiced'])\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 8))\n",
        "\n",
        "# Create a heatmap-style visualization\n",
        "for i, (phoneme, features) in enumerate(phonemes.items()):\n",
        "    y = 5 - i\n",
        "    for j, (feature, value) in enumerate(zip(['Bilabial', 'Stop', 'Voiced'], features)):\n",
        "        color = '#3498db' if value == 1 else '#ecf0f1'\n",
        "        rect = plt.Rectangle((j, y - 0.4), 0.8, 0.8, facecolor=color,\n",
        "                            edgecolor='black', linewidth=2)\n",
        "        ax.add_patch(rect)\n",
        "\n",
        "        # Add value text\n",
        "        text_color = 'white' if value == 1 else 'black'\n",
        "        ax.text(j + 0.4, y, '+' if value == 1 else '−',\n",
        "               ha='center', va='center', fontsize=18,\n",
        "               fontweight='bold', color=text_color)\n",
        "\n",
        "    # Add phoneme label\n",
        "    ax.text(-0.5, y, f'/{phoneme}/',\n",
        "           ha='right', va='center', fontsize=16, fontweight='bold')\n",
        "\n",
        "# Add feature labels\n",
        "feature_labels = ['Bilabial', 'Stop', 'Voiced']\n",
        "for j, label in enumerate(feature_labels):\n",
        "    ax.text(j + 0.4, 6, label, ha='center', va='center',\n",
        "           fontsize=14, fontweight='bold', rotation=0)\n",
        "\n",
        "ax.set_xlim(-1, 3)\n",
        "ax.set_ylim(-0.5, 6.5)\n",
        "ax.axis('off')\n",
        "ax.set_title('Jakobsonian Distinctive Features: Phonemes as Feature Bundles',\n",
        "             fontsize=16, fontweight='bold', pad=20)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-jakobson-features",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is a vectorization of meaning. Each phoneme is represented not by a symbol but by a coordinate in feature space. Two phonemes are similar if their feature vectors are close. The entire phonological system of a language becomes a geometry problem.\n",
        "\n",
        "## The Culinary Triangle\n",
        "\n",
        "Claude Lévi-Strauss, the structural anthropologist, extended this approach beyond language to culture itself. He argued that human thought operates through binary oppositions: nature/culture, raw/cooked, male/female, sacred/profane. These aren't universal truths. They're structural patterns that organize how different societies make sense of experience.\n",
        "\n",
        "His \"culinary triangle\" is a famous example. He analyzed how different cultures process food through two axes: the nature-culture axis (raw vs. transformed) and the means of transformation (cooking vs. rotting). This creates a conceptual space where different food preparation methods occupy specific positions.\n",
        "\n",
        "::: {.column-margin}\n",
        "Lévi-Strauss developed these ideas in *The Raw and the Cooked* (1964), the first volume of his four-volume *Mythologiques* series analyzing the structure of myths across cultures.\n",
        ":::"
      ],
      "id": "19b2a416"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: Lévi-Strauss's culinary triangle maps food preparation methods through binary oppositions.\n",
        "#| label: fig-culinary-triangle\n",
        "#| code-fold: true\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "from matplotlib.patches import FancyArrowPatch\n",
        "\n",
        "fig, ax = plt.subplots(figsize=(10, 10))\n",
        "\n",
        "# Define triangle vertices\n",
        "raw = (0, 0)\n",
        "cooked = (-1.5, 2.5)\n",
        "rotted = (1.5, 2.5)\n",
        "\n",
        "# Draw triangle\n",
        "triangle = plt.Polygon([raw, cooked, rotted], fill=False,\n",
        "                       edgecolor='black', linewidth=3)\n",
        "ax.add_patch(triangle)\n",
        "\n",
        "# Add points\n",
        "points = {'Raw': raw, 'Cooked': cooked, 'Rotted': rotted}\n",
        "for label, (x, y) in points.items():\n",
        "    ax.plot(x, y, 'o', markersize=20, color='#e74c3c', zorder=3)\n",
        "    offset = (0, -0.4) if label == 'Raw' else (0, 0.3)\n",
        "    ax.text(x + offset[0], y + offset[1], label,\n",
        "           fontsize=16, fontweight='bold', ha='center', va='center',\n",
        "           bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))\n",
        "\n",
        "# Add intermediate categories\n",
        "intermediates = {\n",
        "    'Smoked': (-0.5, 0.8),\n",
        "    'Boiled': (-0.9, 1.5),\n",
        "    'Roasted': (-0.3, 1.2),\n",
        "    'Fermented': (0.8, 1.3)\n",
        "}\n",
        "\n",
        "for label, (x, y) in intermediates.items():\n",
        "    ax.plot(x, y, 's', markersize=12, color='#3498db', alpha=0.7, zorder=2)\n",
        "    ax.text(x, y - 0.3, label, fontsize=11, ha='center',\n",
        "           style='italic', color='#2c3e50')\n",
        "\n",
        "# Add axes labels\n",
        "ax.annotate('', xy=(-2, 1.25), xytext=(2, 1.25),\n",
        "           arrowprops=dict(arrowstyle='<->', color='gray', lw=2))\n",
        "ax.text(0, 1.65, 'Culture (transformed)', ha='center',\n",
        "       fontsize=12, fontweight='bold', color='gray')\n",
        "\n",
        "ax.annotate('', xy=(-0.75, -0.5), xytext=(-0.75, 3),\n",
        "           arrowprops=dict(arrowstyle='<->', color='gray', lw=2))\n",
        "ax.text(-1.3, 1.25, 'Elaborated', ha='center', fontsize=12,\n",
        "       fontweight='bold', color='gray', rotation=90)\n",
        "\n",
        "ax.text(0, -1.2, 'Nature (untransformed)', ha='center',\n",
        "       fontsize=12, fontweight='bold', color='gray')\n",
        "\n",
        "ax.set_xlim(-2.5, 2.5)\n",
        "ax.set_ylim(-1.5, 3.5)\n",
        "ax.axis('off')\n",
        "ax.set_title(\"Lévi-Strauss's Culinary Triangle:\\nCulture as Binary Oppositions\",\n",
        "             fontsize=16, fontweight='bold', pad=20)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-culinary-triangle",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Roasted meat sits between raw and cooked (less elaborated cooking). Boiled meat is fully cooked (more elaborated). Fermented foods sit between raw and rotted (cultural transformation through natural processes). Each food type's meaning comes from its position in this structural space, not from any intrinsic property.\n",
        "\n",
        "This is the structuralist thesis in full form: meaning is relational, not substantive. Systems of meaning are systems of differences. To understand anything, map the space of contrasts.\n",
        "\n",
        "## Metaphor and Metonymy: Two Modes of Connection\n",
        "\n",
        "Jakobson identified two fundamental ways that concepts connect: through similarity (metaphor) and through contiguity (metonymy). These aren't just literary devices. They're cognitive structures that organize how we think and how language operates.\n",
        "\n",
        "**Metaphor** works by similarity. \"Juliet is the sun\" connects two unlike things through shared properties (brightness, warmth, centrality). Metaphor lets us understand the abstract through the concrete, the unfamiliar through the familiar. Western philosophy and science tend toward metaphorical thinking: classification systems, taxonomies, and abstraction hierarchies all rely on grouping similar things.\n",
        "\n",
        "**Metonymy** works by contiguity—spatial or conceptual adjacency. \"The White House announced...\" uses a location to refer to the president. \"Hollywood is obsessed with franchises\" uses a place to refer to the film industry. Metonymy captures association, co-occurrence, and context. Eastern philosophy often emphasizes metonymic thinking: understanding things through their relationships and contexts rather than their essential properties.\n",
        "\n",
        "::: {.column-margin}\n",
        "Jakobson argued that aphasia patients show selective impairment of either metaphoric (similarity-based) or metonymic (contiguity-based) operations, suggesting these are fundamental cognitive mechanisms.\n",
        ":::"
      ],
      "id": "6dab9372"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-cap: Metaphor groups by similarity, metonymy by co-occurrence. Different structures of meaning.\n",
        "#| label: fig-metaphor-metonymy\n",
        "#| code-fold: true\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import networkx as nx\n",
        "import numpy as np\n",
        "\n",
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 7))\n",
        "\n",
        "# Metaphor network (similarity clusters)\n",
        "G_metaphor = nx.Graph()\n",
        "clusters = {\n",
        "    'Brightness': ['sun', 'star', 'lamp', 'fire'],\n",
        "    'Water': ['ocean', 'river', 'tears', 'rain'],\n",
        "    'Journey': ['road', 'path', 'voyage', 'quest']\n",
        "}\n",
        "\n",
        "for cluster, words in clusters.items():\n",
        "    for word in words:\n",
        "        G_metaphor.add_node(word, cluster=cluster)\n",
        "    # Connect words within cluster\n",
        "    for i, w1 in enumerate(words):\n",
        "        for w2 in words[i+1:]:\n",
        "            G_metaphor.add_edge(w1, w2)\n",
        "\n",
        "# Position metaphor nodes in clusters\n",
        "pos_metaphor = {}\n",
        "cluster_centers = [(0, 2), (-2, -1), (2, -1)]\n",
        "for (cluster, words), center in zip(clusters.items(), cluster_centers):\n",
        "    angle_step = 2 * np.pi / len(words)\n",
        "    for i, word in enumerate(words):\n",
        "        angle = i * angle_step\n",
        "        pos_metaphor[word] = (center[0] + 0.8 * np.cos(angle),\n",
        "                             center[1] + 0.8 * np.sin(angle))\n",
        "\n",
        "# Draw metaphor network\n",
        "colors = {'Brightness': '#f39c12', 'Water': '#3498db', 'Journey': '#9b59b6'}\n",
        "for cluster, words in clusters.items():\n",
        "    nx.draw_networkx_nodes(G_metaphor, pos_metaphor, nodelist=words,\n",
        "                          node_color=colors[cluster], node_size=1200,\n",
        "                          alpha=0.8, ax=ax1)\n",
        "\n",
        "nx.draw_networkx_edges(G_metaphor, pos_metaphor, alpha=0.3, width=2, ax=ax1)\n",
        "nx.draw_networkx_labels(G_metaphor, pos_metaphor, font_size=9,\n",
        "                       font_weight='bold', ax=ax1)\n",
        "\n",
        "ax1.set_title('Metaphor: Clustering by Similarity', fontsize=14, fontweight='bold')\n",
        "ax1.axis('off')\n",
        "ax1.set_xlim(-3.5, 3.5)\n",
        "ax1.set_ylim(-2.5, 3.5)\n",
        "\n",
        "# Metonymy network (chain of associations)\n",
        "G_metonymy = nx.DiGraph()\n",
        "sequence = [\n",
        "    ('cherry\\nblossoms', 'spring'),\n",
        "    ('spring', 'hanami\\n(viewing)'),\n",
        "    ('hanami\\n(viewing)', 'sake'),\n",
        "    ('sake', 'party'),\n",
        "    ('party', 'friends'),\n",
        "    ('friends', 'memories'),\n",
        "    ('memories', 'nostalgia'),\n",
        "]\n",
        "\n",
        "for source, target in sequence:\n",
        "    G_metonymy.add_edge(source, target)\n",
        "\n",
        "# Position metonymy nodes in a flowing path\n",
        "pos_metonymy = {}\n",
        "x_positions = np.linspace(-3, 3, len(G_metonymy.nodes()))\n",
        "y_positions = [0.5 * np.sin(x * 0.8) for x in x_positions]\n",
        "\n",
        "for i, node in enumerate(G_metonymy.nodes()):\n",
        "    pos_metonymy[node] = (x_positions[i], y_positions[i])\n",
        "\n",
        "# Draw metonymy network\n",
        "nx.draw_networkx_nodes(G_metonymy, pos_metonymy,\n",
        "                      node_color='#e74c3c', node_size=1500,\n",
        "                      alpha=0.8, ax=ax2)\n",
        "\n",
        "nx.draw_networkx_edges(G_metonymy, pos_metonymy,\n",
        "                      edge_color='gray', width=3, alpha=0.6,\n",
        "                      arrowsize=20, arrowstyle='->', ax=ax2,\n",
        "                      connectionstyle='arc3,rad=0.1')\n",
        "\n",
        "nx.draw_networkx_labels(G_metonymy, pos_metonymy, font_size=8,\n",
        "                       font_weight='bold', ax=ax2)\n",
        "\n",
        "ax2.set_title('Metonymy: Chaining by Contiguity', fontsize=14, fontweight='bold')\n",
        "ax2.axis('off')\n",
        "ax2.set_xlim(-4, 4)\n",
        "ax2.set_ylim(-1.5, 1.5)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fig-metaphor-metonymy",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Why does this distinction matter for machine learning? Because different algorithms capture different types of relationships. Classification algorithms and clustering methods are metaphorical—they group by similarity. But sequence models, language models, and graph neural networks are metonymic—they learn from co-occurrence and context. Understanding which type of relationship you're trying to capture shapes which tools you should use.\n",
        "\n",
        "## From Philosophy to Algorithm\n",
        "\n",
        "We've traced a philosophical thread through linguistics, Buddhist logic, structural anthropology, and cognitive science. The insight is consistent: meaning is not intrinsic. It emerges from patterns of difference, opposition, and relationship.\n",
        "\n",
        "This sounds abstract, but it becomes concrete when you try to teach a machine what words mean. You cannot program in definitions. Dictionaries are circular (look up \"large\" and you find \"big\"; look up \"big\" and you find \"large\"). Instead, you need to let the machine discover the structure of language by observing how words relate to each other.\n",
        "\n",
        "That's exactly what word2vec does. It doesn't learn what \"dog\" means by reading a definition. It learns by observing which words appear near \"dog\" in actual text. \"Dog\" appears near \"bark\", \"pet\", \"leash\", \"puppy\". It doesn't appear near \"meow\", \"aquarium\", or \"carburetor\". The meaning of \"dog\" is implicitly defined through this pattern of co-occurrence and exclusion.\n",
        "\n",
        "Word2vec operationalizes Saussure's insight that meaning is differential. It implements Apoha's theory that concepts are defined by exclusion. It builds Jakobson's feature space where similarity is geometric distance. It captures both metaphoric (similarity-based) and metonymic (context-based) relationships.\n",
        "\n",
        "The next section shows how this works mechanically. How do you turn a philosophical theory about the nature of meaning into working code? How do you represent the continuous space of semantic relationships without imposing arbitrary boundaries? The answer involves vector embeddings, contrastive learning, and a mathematical framework that makes structuralism computable.\n",
        "\n",
        "::: {.callout-tip title=\"Try it yourself\"}\n",
        "Pick a concept you use often (democracy, friendship, justice, art). Try to define it without using synonyms or related terms. You'll find it's almost impossible. Now try defining it negatively, through what it is not. Which approach feels more precise? This exercise reveals why structuralism works.\n",
        ":::"
      ],
      "id": "a3250080"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/skojaku-admin/Documents/projects/applied-soft-comp/.venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}