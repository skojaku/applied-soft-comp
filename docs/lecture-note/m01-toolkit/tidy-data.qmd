---
title: "The Tidy Data Philosophy"
jupyter: python3
execute:
    enabled: true
---

## Introduction

It is often said that 80% of data analysis is spent on the process of cleaning and preparing the data. Read the following paper to learn more about the `tidy data` philosophy.

- [Tidy Data  by Hadley Wickham](https://vita.had.co.nz/papers/tidy-data.pdf)".


## What is Tidy Data?

Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types. In tidy data:

1.  **Each variable forms a column.** A variable contains all values that measure the same underlying attribute (like height, temperature, duration) across units.
2.  **Each observation forms a row.** An observation contains all values measured on the same unit (like a person, or a day, or a race) across attributes.
3.  **Each type of observational unit forms a table.** For example, in a study of allergy medication, you might have a table for demographic data, a table for daily medical data, and a table for meteorological data, not just one big table that contains all the data.


Tidy datasets are easy to manipulate, model and visualise. They make it easier to explore, manipulate and analyze the data. And most importantly, tidy formats standardize the way data is organized, making code reusable and reliable.

### What are not tidy data?

Here are five of the most common problems with not tidy datasets:

-   **Column headers are values, not variable names.**
    *For example, a table where months ("Jan", "Feb", "Mar") are the column headers, instead of having a single "Month" column with "Jan", "Feb", etc. as values.*
-   **Multiple variables are stored in one column.**
    *For example, a column named "height_weight" that contains values like "5.5_130", rather than splitting these into separate "height" and "weight" columns.*
-   **Variables are stored in both rows and columns.**
    *For example, a dataset where one piece of information (like gender) is encoded in both a specific column and within the values of another column, making analysis and transformation more difficult.*
-   **Multiple types of observational units are stored in the same table.**
    *For example, a table that contains both patient demographic information and medical test results, mixing fundamentally different kinds of data in one place.*
-   **A single observational unit is stored in multiple tables.**
    *For example, patient information split across one table for addresses, another for test results, and another for appointments—all without a neat way to link them together as single observations.*

## Tidy Tools

Let's learn some tools to tidy your data through some examples.

The following examples are from [Python for Data Science](https://aeturrell.github.io/python4DS/data-tidy.html).

### Melt

Often, data can be stored in a "wide" format, where different columns represent different variables of the same type. For example, think about the following dataset:

```{python}
#| code-fold: true
import pandas as pd
df = pd.DataFrame({'first': ['John', 'Mary'],
                   'last': ['Smith', 'Doe'],
                   'height': [5.5, 5.0],
                   'weight': [130, 110]})
df
```

where "height" and "weight" are separate columns, but tidy data principles ask for each variable to form its own column and each observation to form a row. This "wide" format can make analysis more difficult if you want to compare or plot variables together.

The `pandas.DataFrame.melt()` method fixes this by transforming the data from "wide" to "long" format, making it tidy. After melting, instead of having separate columns for "height" and "weight", you have just one column storing the variable type (like "height" or "weight") and another column with the corresponding value for each observation.

Here’s how it works:

```{python}
import pandas as pd
df_melted = df.melt(
    id_vars=['first', 'last'],
    var_name='quantity',
    value_name='value'
)
df_melted
```

Now each row represents a single measurement (either height or weight) for an individual, rather than having two measurements in one row. This is a key part of "tidy data".

### Pivot

Sometimes, your data is in a "long" format: for instance, you might have a separate row for each type of measurement (like "cases" or "population") for each country and year. This can make it difficult to see all the information about a single observation (for example, all statistics for country A in 2020) at once.

```{python}
#| code-fold: true
import numpy as np

# Long format: each row is a different variable for country and year
df = pd.DataFrame({
    'country': ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'],
    'year': [2020, 2021, 2020, 2021, 2020, 2021, 2020, 2021],
    'variable': ['cases', 'cases', 'population', 'population', 'cases', 'cases', 'population', 'population'],
    'value': [100, 200, 120, 220, 130, 230, 140, 240]
})
df
```

The `pivot()` function solves this problem by reshaping the data so that each observation (combination of country and year) has its measurements as columns. This transforms your data back to a wider, more analyzable format.

Now, each row contains all measurements (“cases”, “population”) for a given country and year—making your data tidy and easier to analyze!

### Stack and Unstack
Sometimes your data uses multi-level column headers, where variables are split across two or more header rows (for example, measurements for different people and types, such as test results for multiple groups shown as columns). This structure can make it awkward to access or visualize the data, as related values are spread apart and grouped by columns.

```{python}
#| code-fold: true
# Example: multi-level columns for two participants (P1, P2) and two attributes (A, B)
header = pd.MultiIndex.from_product([['P1','P2'],['A','B']])
df = pd.DataFrame(np.random.rand(4, 4),
                  columns=header)
df
```

The `stack()` method helps to "tidy" this kind of data by turning one of the levels of columns into a new row index, effectively transforming wide-form data to long-form, so each row represents a single measurement. This makes analysis and plotting easier, as all values of the same variable are stacked in a single column. The `unstack()` method reverses this, spreading data back into columns from the index.

Here’s how `stack()` and `unstack()` work in practice:

```{python}
df.stack(future_stack=True)
```

```{python}
df.stack(future_stack=True).unstack()
```